%\onecolumn
In this section, we define the semantics of the discription language.
For this purpose, we define a machine.
Before we continue, we define context \(k\).
The following grammar defines a set of contexts.
The context contains a hole, written in \hole, in the place of one subexpression.
  \begin{displaymath}
    \begin{array}{lcl}
k     &::=& \hole \\
      & | & k\|\hole\\
      & | & \hole\|k
    \end{array}
  \end{displaymath}
$k[P]$ means to replace the hole in $k$ with $P$.
Moreover, we define a function $Env$ that maps all free variables to closures.
This function is called a environment, and a closure is a pair of an expression and a environment.
environments \(Env\) and colosures \(c\) have mutually recursive definitions.
  \begin{displaymath}
    \begin{array}{rcl}
Env &::=& \mbox{a list of pairs }\langle(X,c),\cdots\rangle\\
k &::=& \{(P,env)|FV(P)\subset dom(Env)\}\\
%v &::=& \{(v,env)|FV(P)\in c\}
    \end{array}
  \end{displaymath}
\(Env[X\leftarrow c]\) means that \((X,c)\) is added into \(Env\), that is, 
\(\{(X,c)\}\cup\{(Y,c')|(Y,c')\in Env \mbox{ and } X\neq Y\}\).

In addition to the above definition, we use the following sets.
  \begin{displaymath}
    \begin{array}{rcl}
ch &::=&\mbox{a list of pairs }\langle(Name,\langle m_1,\cdots,m_n\rangle),\cdots\rangle
    \end{array}
  \end{displaymath}
Channel ch represents a set of channels with which processes communicate each other.
\(ch[a\leftarrow v]\) means that \((a,v)\) is added into \(ch\), that is, 
\(\{(a,v)\}\cup\{(b,v')|(b,v')\in ch \mbox{ and } a\neq b\}\).

A state of the machine is a triple \([(exp,env),k,ch]\) following \cite{Felleisen:2002}.
We define single step of the evaluation function.
\begin{center}
  \begin{tabular}{ll}
\multicolumn{2}{c}{
\inference[Output(1)]
{}
{[(\sim a(v):P,Env),\hole,ch]\trans{\sim a}[(P,Env),\hole,ch[a\leftarrow\langle v\rangle]]}
}\\\\
\multicolumn{2}{c}{
\inference[Output(2)]
{}
{[(\sim a(v):P,Env_1),(Q,Env_2)\|\hole,ch]\trans{\sim a}[(Q,Env_2),\hole\|(P,Env),ch[a\leftarrow\langle v\rangle]]}
}\\\\
\multicolumn{2}{c}{
\inference[Output(3)]
{}
{[(\sim a(v):P,Env_1),\hole\|(Q,Env_2),ch]\trans{\sim a}[(Q,Env_2),(P,Env_1)\|\hole,ch[a\leftarrow\langle v\rangle]]}
}\\\\
\multicolumn{2}{c}{
\inference[Input]
{}
{[(a(x):P,Env),k,ch[a\leftarrow\langle v\rangle]]\trans{a}[(k[P],Env[\langle x\rangle\leftarrow\langle v\rangle]),\hole,ch]}
}\\\\
\multicolumn{2}{c}{
\inference[Sum(1)]
{[(P,Env_{1}),k,ch]\trans{\alpha}[(P',Env_{1}'),k',ch']}
{[(P,Env_{1})\mbox{++}(Q,Env_2),k,ch]\trans{\alpha}[(P',Env_{1}'),k',ch']}
} \\\\
\multicolumn{2}{c}{
\inference[Sum(2)]
{[(Q,Env_{2}),k,ch]\trans{\alpha}[(Q',Env_{2}'),k',ch']}
{[((P,Env_{1})\mbox{++}(Q,Env_{2}),k,ch]\trans{\alpha}[(Q',Env_{2}'),k',ch']}
}\\\\
\multicolumn{2}{c}{
\inference[Com(1)]
{[(P,Env_1),k,ch]\trans{\alpha}[(P',Env_{1}'),k[\hole\|Q],ch']}
{[(P,Env_1)||(Q,Env_2),k,ch]\trans{\alpha}[(P',Env'),k[\hole\|Q],ch']}
}\\\\
\multicolumn{2}{c}{
\inference[Com(2)]
{[(Q,Env_2),k,ch]\trans{\alpha}[(Q',Env_{2}'),k[P\|\hole],ch']}
{[((P,Env_1)||(Q,Env_2),k,ch]\trans{\alpha}[(Q',Env_{2}'),k[P\|\hole],ch']}
}\\\\
\multicolumn{2}{c}{
\inference[Com(3)]
{[(P,Env_1)\|(Q,Env_2),k,ch]\trans{\overline{\alpha}}[(Q,Env_{2}),k[(P',Env_{1}')\|\hole],ch']\\
 [(P,Env_1)\|(Q,Env_2),k,ch]\trans{\alpha}[(P,Env_{1}),k[\hole\|(Q',Env_{2}')],ch'']}
{[(P,Env_1)\|(Q,Env_2),k,ch]\trans{(\overline{\alpha},\alpha)}[(k[(P',Env_{1}')\|(Q',Env_{2}[\langle x\rangle\leftarrow\langle x\rangle])]),\hole,ch]}
}\\\\
\multicolumn{2}{c}{
\inference[Con]
{[(P(x),Env[A\leftarrow P][\langle x\rangle\leftarrow\langle v\rangle]),k,ch]\trans{\alpha}[(P',Env[A\leftarrow P][\langle x\rangle\leftarrow\langle v\rangle]),k,ch]}
{[(A(v),Env[A\leftarrow P]),k,ch]\trans{\alpha}[(P',Env[A\leftarrow P][\langle x\rangle\leftarrow\langle v\rangle]),k,ch]}
}\\\\
%\multicolumn{2}{c}{
%\inference[Def]
%{}
%{[(\mbox{define}\ A\ P,Env),k,ch]\trans{}[(\mbox{ZERO},Env[A\leftarrow P]),k,ch]}
%}\\\\
\inference[If(1)]
{\mbox{eval-val}(B,Env)\\ [(T,Env),k,ch]\trans{\alpha}[(T',Env'),k',ch']}
{[(\mbox{if}\ B\ T\ E,Env),k,ch]\trans{\alpha}[(T',Env'),k',ch']}
&
\inference[If(2)]
{\neg\mbox{eval-val}(B,Env)\\[(E,Env),k,ch]\trans{\alpha}[(E',Env'),k',ch']}
{[(\mbox{if}\ B\ T\ E,Env),k,ch]\trans{\alpha}[(E',Env'),k',ch']}
\\\\
\multicolumn{2}{c}{
\inference[Res]
{\alpha,\bijection{\alpha}\not\in\{\alpha,\cdots\} & [(P,Env),k,ch]\trans{\alpha}[(P',Env'),k',ch']}
{[(P[\alpha,\cdots],Env),k,ch]\trans{\alpha}[(P'[\alpha,\cdots],Env'),k',ch']}
}\\\\
\multicolumn{2}{c}{
\inference[Rel(1)]
{[(P,Env),k,ch]\trans{\alpha}[(P',Env'),k',ch[\alpha'\leftarrow\langle v\rangle]]}
{[(P\{\alpha'\slash\alpha,\cdots\},Env),k,ch]\trans{\alpha '}[(P'\{\alpha'\slash\alpha,\cdots\},Env'),k',ch[\alpha'\leftarrow\langle v\rangle]]}
}\\\\
\multicolumn{2}{c}{
\inference[Rel(2)]
{[(P,Env),k,ch[\alpha\leftarrow\langle v\rangle]]\trans{\alpha}[(P',Env'),k',ch]}
{[(P\{\alpha'\slash\alpha,\cdots\},Env),k,ch[\alpha\leftarrow\langle v\rangle]]\trans{\alpha '}[(P'\{\alpha'\slash\alpha,\cdots\},Env'),k',ch]}
}\\\\
%\infer[\mbox{Bind}]
%{[\mbox{bind}\ A\ string,s]\trans{}[\mbox{STOP},s]}
%{}
%\\\\
\inference[ZERO(1)]
{}
{[(\mbox{ZERO},Env),\hole,ch]\not\trans{}}
&
\inference[ZERO(2)]
{}
{[(\mbox{ZERO},Env),k,ch]\trans{}[k[(\mbox{ZERO},Env)],\hole,ch]}
%\\\\
%\inference[Stop(2)]
%{[\mbox{STOP},s]\not\trans{} & [\mbox{STOP},s]\not\trans{}}
%{[\mbox{STOP}||\mbox{STOP},s]\not\trans{}}\\
%\infer[\mbox{Stop}_3]{[\mbox{STOP}++P,s]\trans{\alpha}[P',s']}
%                     {[P,s]\trans{\alpha}[P',s']}
%&
%\infer[\mbox{Stop}_4]{[\mbox{STOP}++\mbox{STOP},s]\not\trans{}}
%                     {[\mbox{STOP},s]\not\trans{}
%                      & [\mbox{STOP},s]\not\trans{}}
  \end{tabular}
\end{center}
where \(Env[\langle x\rangle\leftarrow\langle v\rangle,\langle y\rangle\leftarrow\langle w\rangle,\cdots]\) means \(Env[\langle x\rangle\leftarrow \langle v\rangle][\langle y\rangle\leftarrow\langle w\rangle]\cdots\), and
\(ch[\alpha\leftarrow \langle v\rangle,\beta\leftarrow \langle w\rangle,\cdots]\) means \(ch[\alpha\leftarrow\langle v\rangle][\beta\leftarrow\langle w\rangle],\cdots\).
