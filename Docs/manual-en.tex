\documentclass[12pt,a4paper,titlepage]{article}
%%%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{graphicx}
\usepackage{fleqn}
\usepackage{latexsym}
\usepackage{listings}
%%%%% theorem.sty
%\usepackage{amsthm}
%\theoremstyle{definition}
%%%
%%%%% theorem.sty
\usepackage{theorem}
\theorembodyfont{\normalfont}
%
% Proof environment with \QED
%
\makeatletter
\newenvironment{proof}[1][\proofname]{\par
  \normalfont
  \topsep6\p@\@plus6\p@ \trivlist
  \item[\hskip\labelsep{\bfseries #1}\@addpunct{\bfseries.}]\ignorespaces
}{%
  \endtrivlist
}
\newcommand{\proofname}{Proof Sketch}
\makeatother
%%%
\theoremstyle{break}
\newtheorem{definition}{DEFINITION}[section]
\newtheorem{axiom}{AXIOM}[section]
\newtheorem{theorem}{THEOREM}[section]
\usepackage[inference]{semantic}
\input{style}
%----------------------------------------------------------
\title{\NHK User's Manual}
\author{Noayuki Nagatou\thanks{PRESYSTEMS Inc. Copyright 2014 Naoyuki Nagatou}\\%
\small PRESYSTEMS Inc.\\[6pt]
\small nagatou@presystems.xyz}
\date{}
%----------------------------------------------------------
\markboth{Copyright 2014 Naoyuki Nagatou}{Copyright 2014 Naoyuki Nagatou}


\begin{document}
  \begin{titlepage}
\maketitle
%
%%% ABSTRACTION
%
\begin{abstract}
\NHK \emph{is a model checking tool developed by us and published according to GPLv3 and later}.

In general, there are two checking processes within the lifecycle of a system.
One is verification of models describing functional specification, 
and the other is testing of real codes implementing the system.
We developed a model checking tool can being used on both processes.
Model checking systematically explores the state space of systems.
The systems are expressed as the model
or real code(or source code) written in programming languages such as C.
There are several model checking tools 
that handle either the models or the real codes,
but not both.
In testing processes of the real codes,
our model checking tool checks both the models and the real codes.
The tool executes the binary code on GDB,
then examines a composition with the model from which the portions of 
the model that correspond to the code being executed
have been eliminated.
A state space of the real code is a set of GDB's breakpoints corresponding to
actions to communicate between the eliminated portion and others,
so the model is written in a modeling language based on process algebra.
This tool enables the re-use of the same model that was used in verification processes.
\end{abstract}
  \end{titlepage}
\tableofcontents
\newpage
\section{Installation}
  Compiling those files needs glib-1.2. You need to install it before doing this.
Please refer the manual to install glib-1.2.
  \begin{enumerate}
\item After installing glib-1.2, \\
    \verb|>| tar -xvzf rccs.tar.gz
\item type the following\\
    \verb|>| cd rccs/src
\item  similarly,\\
    \verb|>| make rccs
  \end{enumerate}
If you cannot compile then please edit the make file for your configuration.
Perhaps, glib is installed into a different place.
\section{Run-Time Options}
\NHK allow us to use the following option to control the behaviour of \NHK.
  \begin{quotation}
rccs [-tisq] [-f FORMULA] [-d TARGET [ARGUMENTS]] [-m MODEL].
  \end{quotation}
When you give both -d and -f, then I examine the target in the verification mode, and give only -f then I verify a given property for a model.
When you don't give both -f and -d, I will run the model in the emulation mode.
%  \begin{quotation}
    \begin{itemize}
\item -t : turns the trace flag on.
\item -f "formula": specifies a formula and moves to verification mode.
\item -d "target" ["arguments"]: specifies a debugging program and moves to collaboration mode.
%\item -m "model" : specifies a source file written in RCCS (Not Yet).
%\item -q : changes channels in RCCS to queue buffer.
%\item -s : changes channels in RCCS to stack buffer (Default).
\item -i : provids the interactive execution mode.
\item -g : stronG view of the semantics (default).
\item -k : weaK view of the semantics.
    \end{itemize}
%  \end{quotation}
%
%%% COMMUNICATION
%
\section{Communication}
Let us try to see a message media for the transmission of information in \NHK.
One of implementations of message medias is a bounded buffer.
The message media discipline is:
  \begin{itemize}
\item The channel is a bidirection channel and a bounded buffer whose size is 1.
\item A sender may always send a message, provided the buffer is not full.
\item If the buffer is full then a sender is blocked.
\item A receiver may always recive a message, provided the buffer is not empty.
\item If the buffer is empty then a receiver is blocked.
  \end{itemize}
The bounded buffer in \NHK takes one message at a time.
We call this buffer a register, and operations write/read.
If a buffer is full/empty then write/read operation is blocked.
To simplify the description, we consider that the buffer is FIFO.
Moreover, communication is connected by bidirectional channel.

The concurrent object is defined by a set of oeprations and a specification that defines the meaning of the object.
The object in \NHK has the following specification.
  \begin{itemize}
\item The order of recieving messages is equal to the order of sending messages.
\item Every value read is written, but not overwritten.
\item No value is written twice.
\item No value is received twice.
\item The order of recieving messages is equal to the order of sending messages.
\item Every value read is written, but not overwritten.
\item The first action is an output action.
  \end{itemize}
Moreover, the shared object has atomicity (linearizability) property.

A pair of an input action and an matching output action in a linearization sequence atomically behaves.
We regard the continious occurence of the matching actions as an atomic communication between an input action and an output action.
%
%%% LINEARIZABILITY
%
\subsection{Atomicity Consistency (Linearizability)}
Sequences of actions in \NHK has linearizability property that Herlihy and Wing define in \cite{Herlihy:1987}.
Linearizability requires each operation should appear to ''take effect'', and the order of nonconcurrent operations should be preserved.

An execution on concurrent objects is modeled by a history, which is a finite sequence of operation invocation and response events.
An action involves two operations to communication media.
One is to write messages to the media as an output action, and another is to read messgaes from it as an input action.
Each operation is a pair consists of an invocation event and the matching response event.
An invocation of an operation is written as \(\inv(op)\), and also an response event is written as \(res(op)\).
  \begin{definition}[Sequencial History]
A history $H$ is sequenctial if:
    \begin{itemize}
\item The first event of history $H$ is an invocation of an action.
\item Each invocation event, except possibly the last, is immediately followed by a matching response event.
\item Each response event, except possibly the last, is immediately followed by an invocation event.
    \end{itemize}
  \end{definition}
Let $a$ be any process \(P_i\) or any object \(X\).
\(H|a\) denotes the prjection of $H$ on $a$.
Two histories are equivalent if for every process \(P_i\), \(H|P_i=H'|P_i\).
A history is well-formed if a projection on each process is sequential.
All histories considered in this paper are assumed to be well-formed.

A history $H$ induces an irreflexive relation \(\prec_{H}\) on a set of operations.
\begin{definition}[Partial Order on Oeprations]
  \begin{displaymath}
op_1\prec_{H}op_2\mbox{ if }\res(op_1)\mbox{ precedes }\inv(op_2)\mbox{ in }H.
  \end{displaymath}
\end{definition}
If $H$ is sequential then \(\prec_{H}\) is total.

The next introduces the condition of linearizability.
\begin{definition}[Linearizability]
There is a sequential history $S$ such that:
  \begin{itemize}
\item history $H$ is equivalent to some legal sequential history $S$,
\item \(\prec_{H}\subseteq\prec_{S}\), and
\item \(\prec_{S}\) is total order.
  \end{itemize}
\end{definition}

Given a linearizable history, there may be more than one linearization.
A possiblity for liniarization is a pair \(\langle S,P\rangle\), where $S$ is a linearization of a given history and $P$ is a set of pending operations which are not completed to construct $S$.
\(Poss\) denotes a set of positilities.
$Poss$ is caputured by the following three axioms.
  \begin{axiom}[Closure]
if \(\langle S,P\rangle\in Poss\) then
    \begin{displaymath}
      \begin{aligned}
\forall\inv(op)&\in P\exists\res(op).S\inv(op)\res(op)\mbox{ is legal}\\
&\Rightarrow\langle S\inv(op)\res(op),P-\{\inv(op)\}\rangle\in Poss
      \end{aligned}
    \end{displaymath}
  \end{axiom}
The axiom states that if $S$ is a linearization of $H$ , \(\inv(op)\) is a pending invocation in $H$ that is not completed to form $S$, and \(S'=S\inv(op)\res(op)\) is a legal sequential history, then $S'$ is also a linearization of $H$.
  \begin{axiom}[Invocation]
    \begin{displaymath}
\{\langle S,P\rangle\in Poss\}\inv(op)\{\langle S,P\cup\{\inv(op)\}\rangle\in Poss\}
    \end{displaymath}
  \end{axiom}
Axiom Invocation states that any invocation of $H$ is also a linearization of \(H\inv(op)\).
  \begin{axiom}[Response]
    \begin{displaymath}
\{\langle S,P\rangle\in Poss\mbox{ and }\inv(op)\not\in P\mbox{ and }\res(op)=\last(S,A)\}\res(op)\{\langle S,P\rangle\in Poss\}
    \end{displaymath}
  \end{axiom}
Axiom Response states that any linearization of $H$ in which the pending \(\inv(op)\) is completed with \(\res(op)\) is also a linearization of \(H\res(op)\).
\(\last(S,A)\) is the response to $A$'s last invocation in the sequential history $S$.
An operation completion decides the order of the operation, and then the invocation of the operation in $P$ on $Poss$ is removed.
%
%%% NHK Message Media
%
\subsection{\NHK Message Media}
The bounded buffer in \NHK takes one message at a time from that message media decipline.
Operation \(\enq\), if the buffer is empty, places a message in the buffer, otherwise it is blocked.
Operation \(\deq\), if the buffer is full, reads a message from the buffer, otherwise it is blocked.
The message media decipline leads the axioms.
$m$ denotes a state of a message media, and \([v]\) denotes a queue list.
  \begin{axiom}[Enqueue]
    \begin{displaymath}
\{m=\emptyset\}[\inv(\enq(v))/\res(\enq(v))]\{m=[v]\}
    \end{displaymath}
  \end{axiom}
  \begin{axiom}[Dequeue]
    \begin{displaymath}
\{m\neq\emptyset\mbox{ and }m=[v]\}[\inv(\deq())/\res(\deq())]\{m=\emptyset\mbox{ and }v=\res(\deq())\}
    \end{displaymath}
  \end{axiom}
  \begin{theorem}
The message media with the enqueue and dequeue operations is an atomic object.
  \end{theorem}
  \begin{proof}
Let $H$ is a history on the message media.
\NHK in current implementation immediately completes each operation.
Therefore, every $H$ is a sequential history, and for each history, \(\prec_{H}\) is total order.
Thus, the message media is an atomic object.
Because atomicity is a local propety (see Theorem 1 in \cite{Herlihy:1987}) the whole of the message media is also atomic.
\QED
  \end{proof}

Moreover, we show that every transition between a sender and a receiver in \NHK is atomic.
  \begin{theorem}
A transition between a sender and a receiver in \NHK is atomic.
  \end{theorem}
  \begin{proof}
\QED
  \end{proof}

%
%%% SYNTAX
%
\section{Syntax of Model Description Language}
\subsection{Primitive Types}
RCCS has two types, integer and string.
Operator {\tt +,-,/,*} are defined over these types.
\subsection{Special Actions and Processes}
Action {\tt key} and {\tt display} are special actions. 
{\tt key} is used as an input action corresponding to the standard input, and {\tt display} is used as an output action corresponding to the standard output.
{\tt accept} is used to represents accept states of an automaton produced from a given LTL formula in verification mode.
Those special actions distiguish between upper letters and lower letters.

Process {\tt ZERO} and {\tt STOP} are a special process that means do nothing, not terminate the whole.
\NHK uses a special process {\tt INIT\_STATE} in verification mode.
The process menas an initial state of an automaton for a LTL formula given by users.
{\tt ABORT} terminates the whole process for an automaton, but users cannot use in a model.
Those special processes do not distinguish between upper letters and lower letters.
\subsection{Scope}
In expression (define P (x) body), the scope of x becomes body.
In expression (\bijection{a}(x)\(\colon\) body), the scope of x becomes body.

Unfortinately, we use dynamic binding.
In future, we will fix it.
\subsection{Syntax of the Discription Language}\label{sec:RCCSsyntax}
\input{ss02-grm}
\subsection{Sorts and Derivatives of Processes}
We make the notion of sort which is a little difference from syntactic sort in \cite{mil:book}.
If actions of a process \(P\) and all its derivatives
  \begin{displaymath}
    \begin{array}{rcl}
\sort{ZERO}&=&\emptyset\\
\sort{a\colon P}&=&\{a\}\cup\sort{P}\\
\sort{\sim a\colon P}&=&\{\sim a\}\cup\sort{P}\\
\sort{P\mbox{++}Q}&=&\sort{P}\cup\sort{Q}\\
\sort{P\|Q}&=&\sort{P}\cup\sort{Q}\\
\sort{\mbox{if}\ b\ P\ Q}&=&\sort{P}\cup\sort{Q}\\
\sort{A}&=&\sort{P} \mbox{  if $A\procdef P$}
    \end{array}
  \end{displaymath}
We distiguish names and co-names, and the observation of pairs of matching actions is possible because it is used to determine a next transition of the entier of processes.

We make the notion of syntactic derivative of sort \(\sort{P}\) which is used in the definition of operatinal semantics.
All derivatives lie in \(\sort{P}\) of \(P\) is syntactic immediate derivatives.
Describing an action sequence \(\alpha_1,\cdots,\alpha_n\) in which each element is an element of \(\sort{P}\) of \(P\), we call a process of the sequence
 and a set of them writes \(\derivative{P}\).
\(\derivative{ZERO}\) is \(\{ZERO\}\).
\subsection{RCCS Operatinal Semantics}\label{OPERATINAL_SEMANTICS}
\input{manual-sem}
\section{Coroutine-Like Sequencing}
An important application of coroutine is discrete event simulation, where coroutine may be used to simulate parallel processes within the framework of a sequential program.
\section{Syntax of Formulae}
We use LTL to describe goal properties of processes.
We first assume that a trace has initial states and is a finite sequence of states.
We write the length of trace \(\sigma=s_0\,s_1\,\cdots\,s_n\) to \(|\sigma|\) in which \(|\sigma|\) is \(n+1\).
We write the suffix of \(\sigma=s_0\,s_1\,\cdots\,s_i\,\cdots\,s_n\) starting at \(i\) as \(\suffix{\sigma}{i}=s_i\,\cdots\,s_n\), and the \(i^{\mbox{th}}\) state as \(\sigma^i\).

We assume a vocabulary \(x,y,z,\cdots\) of variables for data values.
For each state, variables are assigned to a single value.
A state formula is any well-formed first-order formula constructed over the given variables.
Such state formulas are evaluated on a single state to a boolean value.
If the evaluation of state formula \(p\) becomes true over \(s\), then we write \(s\lsquarebracket p\rsquarebracket=\true\) and say that \(s\) satisfies \(p\), where $\true$ and $\false$ are truth values, denoting \(true\) and \(false\) respectively.
Let $\varphi$ and $\psi$ be temporal formulas, a temporal formula is inductively constructed as follows:
  \begin{itemize}
\item a state formula is a temporal formula,
\item the negation of a temporal formula \(\neg\varphi\) is a temporal formula,
\item \(\varphi\vee\psi\) and \(\varphi\wedge\psi\) are temporal formulas, and
\item \(\ltlbox\,\varphi\), \(\ltldiammond\,\varphi\), \(\ltlnext\,\varphi\), and \(\varphi\ltluntil\psi\) are temporal formulas.
  \end{itemize}

We provide the formal syntax with BNF notation.
\input{manual-ltlgrm}
\section{Semantics of Property Description Language}
We next define two semantics of temporal formulas over a finite trace according to \cite{Eisner:2003}.
If trace \(\sigma\) satisfies property \(\varphi\), then we write \(\sigma\models\varphi\).
\subsection{Strong Semantics}
Furthermore,
  \begin{itemize}
\item if $p$ is a state formula, then \(\sigma\models p\) iff \(\sigma^0\lsquarebracket p\rsquarebracket=\true\) and \(|\sigma|\neq 0\),
\item \(\sigma\models\neg\varphi\) iff \(\sigma\not\models\varphi\),
\item \(\sigma\models\varphi\vee\psi\) iff \(\sigma\models\varphi\) or \(\sigma\models\psi\),
\item \(\sigma\models\varphi\wedge\psi\) iff \(\sigma\models\varphi\) and \(\sigma\models\psi\),
\item \(\sigma\models\ltlbox\varphi\) iff for all \(0\leq i<|\sigma|\), \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltldiammond\varphi\) iff there exists \(0\leq i<|\sigma|\) such that \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltlnext\varphi\) iff \(\sigma'\models\varphi\) where \(\sigma'=\sigma\) if \(|\sigma|=1\) and \(\sigma'=\suffix{\sigma}{1}\) if \(|\sigma|>1\),
\item \(\sigma\models\varphi\ltluntil\psi\) iff there exists \(0\leq k<|\sigma|\) s.t. \(\sigma\models\psi\) and for all \(j<k\), \(\sigma\models\varphi\).
  \end{itemize}

A formula \(\varphi\) is satisfiable if there exists a sequence \(\sigma\) such that \(\sigma\models \varphi\).
Given set of traces $T$ and formula \(\varphi\), \(\varphi\) is valid over $T$ if for all \(\sigma\in T\), \(\sigma\models\varphi\).
\subsection{Weak Semantics}
Furthermore,
  \begin{itemize}
\item if $p$ is a state formula, then \(\sigma\models p\) iff \(\sigma^0\lsquarebracket p\rsquarebracket=\true\) or \(|\sigma|=0\),
\item \(\sigma\models\neg\varphi\) iff \(\sigma\not\models\varphi\),
\item \(\sigma\models\varphi\vee\psi\) iff \(\sigma\models\varphi\) or \(\sigma\models\psi\),
\item \(\sigma\models\varphi\wedge\psi\) iff \(\sigma\models\varphi\) and \(\sigma\models\psi\),
\item \(\sigma\models\ltlbox\varphi\) iff for all \(0\leq i<|\sigma|\), \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltldiammond\varphi\) iff there exists \(0\leq i<|\sigma|\) such that \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltlnext\varphi\) iff \(\sigma'\models\varphi\) where \(\sigma'=\sigma\) if \(|\sigma|=1\) and \(\sigma'=\suffix{\sigma}{1}\) if \(|\sigma|>1\),
\item \(\sigma\models\varphi\ltluntil\psi\) iff there exists \(0\leq k<|\sigma|\) s.t. \(\sigma\models\psi\) and for all \(j<k\), \(\sigma\models\varphi\).
  \end{itemize}
%
%%% RELATIONSHIPS BETWEEN MODELS AND FORMLAE
%
\section{Relationships between Models and Formlae}
In this subsection, we describe the relationship between algebraic models and LTL formulas.
The modeling language enables us to pass values via input prefix \(\alpha(e)\) and output prefix \(\bijection{\alpha}(x)\) with the same name.
Execution of \(\alpha(e)\) produces  value \(v\) of \(e\).
Execution of \(\bijection{\alpha}(x)\) causes a single assignment to \(x\).
Furthermore, the execution of two actions causes atomic assignment \(x \colon = v\), that is, communication between two agents produces a new state by changing the values of the variables.
This is similar to the first paragraph in Section~3.3 of \cite[page 290]{lamport84hoare}.

This atomic assignment changes states, and  we represent the change as \(s[v/x]\), which denotes a change in the values of \(x\) in \(s\) to \(v\).
A state is a mapping from variables to values.
Assuming that \(\tt Var_E\) is a set of variables that appears in prefixes in agent \(E\) with range \(\tt V\), \(s\colon Var_E\rightarrow {\tt V}\).
For example, the evaluation \(s\lsquarebracket x=y\rsquarebracket\) of \(x=y\) at \(s\) becomes \(s\lsquarebracket x\rsquarebracket=s\lsquarebracket y\rsquarebracket\), and at \(s[v/x]\), \(s[v/x]\lsquarebracket x\rsquarebracket=s[v/x]\lsquarebracket y\rsquarebracket\), i.e., \(v=s[y]\).

Therefore, communication between agents produces a sequence of assignments, which then produces a sequence of state changes called a trace.
Let a set of traces produced by agent \(E\) be \(T\).
If for all traces \(\sigma\in T\), \(\sigma\models\varphi\), then we state that \(\varphi\) is valid over \(E\) and write \(E\models\varphi\).
%
%%% TRANSITION OF AUTOMATA
%
\subsection{Transition of Automata}
A \buchi automaton $m$ contains of five components:
  \begin{itemize}
\item A finite set of states, denoted $Q$.
\item A finite set of input symboles, denoted $\Sigma$.
\item A transition function $\delta$ that takes a state and an input symbol, and returns a next state.
If $q$ is a state, and $s$ is an input symbol, then \(\delta(q,a)\) returns state $p$.
\item A start state $q_0$ is a state in $Q$.
\item A set of accepting states $Q_{\infty}$ is a subset of $Q$.
  \end{itemize}
In this paper, an input symbol becomes a state of a model.
We talk about an automaton $m$ in \emph{five-tuple} notation: \((Q,\Sigma,\delta,q_0,Q_{\infty})\).

Now, we need to make the notion of the language that an automaton accepts.
To do this, we define an extended transition function.
The extended transition function constructed from $\delta$ is called \(\hat{\delta}\).
We define \(\hat{\delta}\) by induction on the length of an input string $\sigma$, as follows:
  \begin{displaymath}
\hat{\delta}(q,\sigma)=\left\{
      \begin{array}{ll}
q & \mbox{if \(|\sigma |=0\)}\\
\delta(\hat{\delta}(q,\sigma^{..n-1}),\sigma^{n}) & \mbox{if \(0<|\sigma |<\omega\)}.
      \end{array}
\right.
  \end{displaymath}
We define the laguage \({\cal L} (m)\) of automaton $m$.
Let \(INF(\rho)\) be a set of automaton states that appear infinitely often in while reading $\sigma$,
then $\sigma$ is accepted by $m$ if and only if \(INF(\rho)\cap Q_{\infty}\neq\emptyset\).
Thus,
  \begin{displaymath}
{\cal L}(m)=\{\sigma\mid \rho^0=q^0, \forall i\colon\rho^i=\hat{\delta}(q_0,\sigma^{..i})\mbox{, and }INF(\rho)\cap Q_{\infty}\neq\emptyset\}.
  \end{displaymath}

\(\eta\) depends on weak or strong semantics.
In weak semantics, \(\eta\) is \(q\) that is regarded as an element of \(Q_{\infty}\).
In strong semantics, \(\eta\) is \(\Lambda\), where \(\Lambda\) is inconsistency.
%
%%% CORRESPONDENCE
%
\subsection{Correspondence between Models and Formulae}
We describe a correspondence between a model and a \buchi automaton of a formulae of a property which the model are required.
The correspondece is expressed with Hoare triple: \{P\}$\alpha$\{P'\},
where $P$ and $P'$ are boolean predicates, and $\alpha$ is an action which a model performs.

An automaton $m$ enters an automaton state \(q_j\) if there exists a history containing program state $s$ and $m$ is transformed from \(q_i\) into \(q_j\) by reading $s$.
We define \emph{correspondence invariant} by induction \cite{alpern:1987}.
\begin{definition}[Correspondece Basis]
  \begin{displaymath}
\forall i\colon q_j\in Q\mbox{ and }(Init_{\pi}\wedge T_{0j})\Rightarrow C_j,
  \end{displaymath}
where \(Init_{\pi}\) is the initial states of model \(\pi\).
\end{definition}
\begin{definition}[Correspondece Induction]
  \begin{displaymath}
\forall \alpha\colon\forall i\colon\alpha\in A\cup\bijection{A}\mbox{ and }q_i\in Q\mbox{ and }
\{C_i\}\alpha\{\wedge_{q_j\in Q}(T_{ij}\Rightarrow C_j)\}.
  \end{displaymath}
\end{definition}

%
%%% Proving Safety Propeties
%
\subsection{Proving Safety Properties}
A model \(\pi\) written by our model language has the form: \(\pi=\pi_1\|\cdots\|\pi_n\).
Processes synchronize and communicate using input actions and output actions.
For a channel \(a\), a value of \(exp\) and a variable \(var\), execution of an output action
  \begin{displaymath}
\bijection{a}(exp)
  \end{displaymath}
causes the transfer of the value of \(exp\), and execution of a matching input action 
  \begin{displaymath}
a(var)
  \end{displaymath}
,which some other process performs, causes recieve from channel \(a\).
an input action is deleyed until some matching output action.

Two matching actions are executed as an atomic action which causes an assignment to \(var\):
  \begin{displaymath}
var\,=\,exp.
  \end{displaymath}
The atomic assignment which consists of two actions \(\bijection{a}\) and \(a\) occurs as a free-standing statement.
We regard the atomic assignment above as a fragment of models.

The set of atomic actions which make up program \(\pi\) is denoted \(\alpha[\pi]\).
If \(\pi\) is composed of fragments \(\pi_1,\cdots,\pi_n\) then:
  \begin{displaymath}
\alpha[\pi]=\alpha[\pi_1]\cup\cdots\cup\alpha[\pi_n]\cup\alpha[a_1]\cup\cdots\cup\alpha[a_n].
  \end{displaymath}

The tool gurantee matching semantics between input and output actions.
For example, \(P_1\|P_2\) in which each process is defined as follows does not produce input-output pairs \((\bijection{a}(1),a(x))\) and \((\bijection{a}(2),a(y))\):
  \begin{displaymath}
    \begin{array}{lcr}
P_1&=&a(x)\colon ZERO\mbox{++}\bijection{a}(0)\colon a(y)\colon ZERO,\\
P_2&=&\bijection{a}(2)\colon ZERO\mbox{++}a(z)\colon\bijection{a}(1)\colon ZERO.\\
    \end{array}
  \end{displaymath}

We present the following proof rules for all possible constructs of processes, according to \cite{Apt:1980}.
  \begin{displaymath}
\infer[\mbox{Input}]{\{p\}a(x)\{q\}}
                    {}
  \end{displaymath}
This axiom corresponds to A.1 in \cite{Apt:1980}.
The post assertion in this axiom will be checked against a corresponging output action with which some process cooperates.
  \begin{displaymath}
\infer[\mbox{Output}]{\{p\}\bijection{a}(y)\{q\}}
                    {}
  \end{displaymath}
This axiom may look strange since it has no side-effect.
We introduce this axiom corresponding to A.2' in \cite{Apt:1980} because the modelling language allows output actions without matching inputs.
Communication \(\{p\}\alpha(x)\colon P\|\bijection{\alpha}(y)\colon Q\{q\}\) does not derivates an arbitrary predicate.
The form of $q$ restricts to the formula of \(\{p\}\alpha(x)\colon P\|\bijection{\alpha}(y)\colon Q\{x=y\wedge p\}\) where $x$ is not free in $p$.

Action prefixes mean sequencial execiton of actions.
This syntactical structure provids the following rule.
  \begin{displaymath}
\infer[\mbox{Sequence}]
      {\{p\}[\alpha\colon P]\{q\}}
      {\{p\}\alpha\{p'\}\ \{'p\}P\{q\}}
  \end{displaymath}

The meaning of the following rule is that the post condition of summation must be estabilished along each possible path.
  \begin{displaymath}
\infer[\mbox{Summation}]{\{p\}P\mbox{++}Q\{q\}}
                        {\{p\}P\{q\}\ \{p\}Q\{q\}}
  \end{displaymath}
Using these axioms and rules, we can establish the proof for a formula for each process.

We now present a proof rule and an axiom for communication among processes.
The rule to used to deduce a property of \(P\|Q\) has the following form:
  \begin{displaymath}
\infer[\mbox{Composition}]{\{p_1\wedge p_2\}P\|Q\{q_1\wedge q_2\}}
                        {\{p_1\}P\{q_1\}\ \{p_2\}Q\{q_2\}}
  \end{displaymath}
The meaning of this rule is that proofs cooperate to help each other proof to validate the post conditions of input/output actions.
We shall need the following axiom to establish cooperation:
  \begin{displaymath}
\infer[\mbox{Communication}]
      {\{True\}[a(x)\colon P\|\bijection{a}(y)\colon Q]\{x=y\}}
      {}
  \end{displaymath}
%
%%% BIBLIOGRAPHY
%
\bibliographystyle{alpha}
\bibliography{reference}

\end{document}

