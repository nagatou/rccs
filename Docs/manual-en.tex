\documentclass[12pt,a4paper,titlepage]{article}
%%%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{graphicx}
\usepackage{fleqn}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{lscape}
%%%%% theorem.sty
%\usepackage{amsthm}
%\theoremstyle{definition}
%%%
%%%%% theorem.sty
\usepackage{theorem}
\theorembodyfont{\normalfont}
%
% Proof environment with \QED
%
\makeatletter
\newenvironment{proof}[1][\proofname]{\par
  \normalfont
  \topsep6\p@\@plus6\p@ \trivlist
  \item[\hskip\labelsep{\bfseries #1}\@addpunct{\bfseries.}]\ignorespaces
}{%
  \endtrivlist
}
\newcommand{\proofname}{Proof Sketch}
\makeatother
%%%
\theoremstyle{break}
\newtheorem{definition}{DEFINITION}[section]
\newtheorem{axiom}{AXIOM}[section]
\newtheorem{theorem}{THEOREM}[section]
\newtheorem{lemma}{LEMMA}[section]
\usepackage[inference]{semantic}
\input{style}
%----------------------------------------------------------
\title{Welcome to the world of \NHK\\
{\small\textemdash Install Manual and Specification\textemdash}}
\author{Naoyuki Nagatou\thanks{PRESYSTEMS Inc. Copyright 2014 Naoyuki Nagatou}\\%
\small PRESYSTEMS Inc.\\[6pt]
\small nagatou@presystems.xyz}
\date{}
%----------------------------------------------------------
\markboth{Copyright 2014 Naoyuki Nagatou}{Copyright 2014 Naoyuki Nagatou}


\begin{document}
  \begin{titlepage}
\maketitle
%
%%% ABSTRACTION
%
\begin{abstract}
\NHK \emph{is a model checking tool developed by us and published according to GPLv3 and later}.

In general, there are two checking processes within the lifecycle of a system.
One is verification of models describing functional specification, 
and the other is testing of real codes implementing the system.
We developed a model checking tool can being used on both processes.
Model checking systematically explores the state space of systems.
The systems are expressed as the model
or real code(or source code) written in programming languages such as C.
There are several model checking tools 
that handle either the models or the real codes,
but not both.
In testing processes of the real codes,
our model checking tool checks both the models and the real codes.
The tool executes the binary code on GDB,
then examines a composition with the model from which the portions of 
the model that correspond to the code being executed
have been eliminated.
A state space of the real code is a set of GDB's breakpoints corresponding to
actions to communicate between the eliminated portion and others,
so the model is written in a modeling language based on process algebra.
This tool enables the re-use of the same model that was used in verification processes.
\end{abstract}
  \end{titlepage}
\tableofcontents
\newpage
\section{Installation}
  Compiling those files needs glib-1.2. You need to install it before doing this.
Please refer the manual to install glib-1.2.
  \begin{enumerate}
\item After installing glib-1.2, \\
    \verb|>| tar -xvzf rccs.tar.gz
\item type the following\\
    \verb|>| cd rccs/src
\item  similarly,\\
    \verb|>| make rccs
  \end{enumerate}
If you cannot compile then please edit the make file for your configuration.
Perhaps, glib is installed into a different place.
\section{Run-Time Options}
\NHK allow us to use the following option to control the behaviour of \NHK.
  \begin{quotation}
rccs [-tigk] [-f FORMULA] [-d TARGET [ARGUMENTS]] [-m MODEL].
  \end{quotation}
When you give both -d and -f, then I examine the target in the verification mode, and give only -f then I verify a given property for a model.
When you don't give both -f and -d, I will run the model in the emulation mode.
Option -i provides interactive mode for users.
When evaluation reaches to a binary operator in process expression, you can choose a left or right operand.
The evaluation resumes after that choice.
Option -g and -k switch the semantics of LTL formulae.
-g turns into strong view and -k turns into weak view.
%  \begin{quotation}
    \begin{itemize}
\item -t : turns the trace flag on.
\item -f "formula": specifies a formula and moves to verification mode.
\item -d "target" ["arguments"]: specifies a debugging program and moves to collaboration mode.
\item -m "model" : specifies a source file for a model written in RCCS (Not Yet).
%\item -q : changes channels in RCCS to queue buffer.
%\item -s : changes channels in RCCS to stack buffer (default).
\item -i : provides the interactive execution mode.
\item -g : stronG view of the semantics of formulae (default).
\item -k : weaK view of the semantics of formulae.
    \end{itemize}
%  \end{quotation}
%
%%% COMMUNICATION
%
\section{Communication}
Let us try to see a message media for the transmission of information in \NHK.
One of implementations of message medias is a bounded buffer.
The message media discipline is:
  \begin{itemize}
\item The channel is a bidirection channel and a bounded buffer whose size is 1.
\item A sender may always send a message, provided the buffer is not full.
\item If the buffer is full then a sender is blocked.
\item A receiver may always receive a message, provided the buffer is not empty.
\item If the buffer is empty then a receiver is blocked.
  \end{itemize}
The bounded buffer in \NHK takes one message at a time.
We call this buffer a register, and operations write/read.
If a buffer is full/empty then write/read operation is blocked.
To simplify the description, we consider that the buffer is FIFO.
Moreover, communication is connected by bidirectional channel.

A concurrent object is defined by a set of operations and a specification that defines the meaning of the object.
Message channels in \NHK has the following specification.
  \begin{itemize}
\item One output action matches to one input action.
\item One input action match's to one output action.
\item Every value read is written, but not overwritten.
\item The first action of a history is an output action.
\item An output action write values to a channel, provided a empty channel.
\item An input action read values from a channel, provider a channel is not empty.
\item No value is written twice.
\item No value is read twice.
  \end{itemize}

Moreover, the shared object has atomicity property (linearizability).
A contiguous occurrence of the matching actions is an atomic communication among matching actions.
A pair of an input action and an matching output action in a sequential history atomically behaves.
%
%%% LINEARIZABILITY
%
\subsection{Atomicity Consistency (Linearizability)}
Sequences of actions in \NHK has linearizability property that Herlihy and Wing define in \cite{Herlihy:1987}.
Linearizability requires each operation should appear to ''take effect'', and the order of nonconcurrent operations should be preserved.

An execution on concurrent objects is modeled by a history, which is a finite sequence of operation invocation and response events.
An action involves two operations to communication media.
One is to write messages to the media as an output action, and another is to read messages from it as an input action.
Each operation is a pair consists of an invocation event and the matching response event.
An invocation of an operation is written as \(\inv(op)\), and also an response event is written as \(res(op)\).
  \begin{definition}[Sequencial History]
A history $H$ is sequential if:
    \begin{itemize}
\item The first event of history $H$ is an invocation of an action.
\item Each invocation event, except possibly the last, is immediately followed by a matching response event.
\item Each response event, except possibly the last, is immediately followed by an invocation event.
    \end{itemize}
  \end{definition}
Let $a$ be any process \(P_i\) or any object \(X\).
\(H|a\) denotes the projection of $H$ on $a$.
Two histories are equivalent if for every process \(P_i\), \(H|P_i=H'|P_i\).
A history is well-formed if a projection on each process is sequential.
All histories considered in this paper are assumed to be well-formed.

A history $H$ induces an irreflexive relation \(\prec_{H}\) on a set of operations.
\begin{definition}[Partial Order on Oeprations]
  \begin{displaymath}
op_1\prec_{H}op_2{\tt if }\res(op_1)\mbox{ precedes }\inv(op_2)\mbox{ in }H.
  \end{displaymath}
\end{definition}
If $H$ is sequential then \(\prec_{H}\) is total.

The next introduces the condition of linearizability.
\begin{definition}[Linearizability]
There is a sequential history $S$ such that:
  \begin{itemize}
\item history $H$ is equivalent to some legal sequential history $S$,
\item \(\prec_{H}\subseteq\prec_{S}\), and
\item \(\prec_{S}\) is total order.
  \end{itemize}
\end{definition}

Given a linearizable history, there may be more than one linearization.
A possibility for linearization is a pair \(\langle S,P\rangle\), where $S$ is a linearization of a given history and $P$ is a set of pending operations which are not completed to construct $S$.
\(Poss_H\) denotes a set of possibilities for history $H$.
$Poss$ is captured by the following three axioms.
  \begin{axiom}[Closure]\label{ax:closure}
if \(\langle S,P\rangle\in Poss\) then
    \begin{displaymath}
      \begin{aligned}
\forall\inv(op)&\in P.\,\exists\res(op).\,S\inv(op)\res(op)\mbox{ is legal}\\
&\Rightarrow\langle S\inv(op)\res(op),P-\{\inv(op)\}\rangle\in Poss
      \end{aligned}
    \end{displaymath}
  \end{axiom}
The axiom states that if $S$ is a linearization of $H$ , \(\inv(op)\) is a pending invocation in $H$ that is not completed to form $S$, and \(S'=S\inv(op)\res(op)\) is a legal sequential history, then $S'$ is also a linearization of $H$.
  \begin{axiom}[Invocation]
    \begin{displaymath}
\{\langle S,P\rangle\in Poss\}\inv(op)\{\langle S,P\cup\{\inv(op)\}\rangle\in Poss'\}
    \end{displaymath}
  \end{axiom}
Axiom Invocation states that any invocation of $H$ is also a linearization of \(H\inv(op)\).
  \begin{axiom}[Response]\label{ax:response}
    \begin{displaymath}
\{\langle S,P\rangle\in Poss\mbox{ and }\inv(op)\not\in P\mbox{ and }\res(op)=\last(S)\}\res(op)\{\langle S,P\rangle\in Poss'\}
    \end{displaymath}
  \end{axiom}
Axiom Response states that any linearization of $H$ in which the pending \(\inv(op)\) is completed with \(\res(op)\) is also a linearization of \(H\res(op)\).
\(\last(S,A)\) is the response to $A$'s last invocation in the sequential history $S$.
An operation completion decides the order of the operation, and then the invocation of the operation in $P$ on $Poss$ is removed.
%
%%% NHK Message Media
%
\subsection{\NHK Message Media}
The bounded buffer in \NHK takes one message at a time from that message media discipline.
Operation \(\enq\), if the buffer is empty, places a message in the buffer, otherwise it is blocked.
Operation \(\deq\), if the buffer is full, reads a message from the buffer, otherwise it is blocked.
A specification is a set of axioms.
The message media discipline leads the axioms.
$m$ denotes a state of a message media, \([v]\) denotes a queue list, and $v$ is a items in a queue.
  \begin{axiom}[Enqueue]\label{ax:enque}
    \begin{displaymath}
\{m=\emptyset\}[\inv(\enq(v))/\res(\enq(v))]\{m=[v]\}
    \end{displaymath}
  \end{axiom}
  \begin{axiom}[Dequeue]\label{ax:deque}
    \begin{displaymath}
\{m\neq\emptyset\mbox{ and }m=[v]\}[\inv(\deq())/\res(\deq())]\{m=\emptyset\mbox{ and }v=\res(\deq())\}
    \end{displaymath}
  \end{axiom}
The above axioms imply the following \thref{th:bound}.
  \begin{theorem}\label{th:bound}
If $m$ is empty initially then
    \begin{displaymath}
0\leq\mbox{length}(m)\leq 1,
    \end{displaymath}
where \(\length\) provides the number of items in buffer $m$.
  \end{theorem}
  \begin{proof}
Operation \(\enq\), if the buffer is not empty then it is blocked, and \(\deq\), if the buffer is empty then it is blocked.
When \(\length(m)\) is empty initially then \(\length(m)\) is at most 1.
\QED
  \end{proof}

Let $H$ is a history on the message media.
\NHK in current implementation immediately completes each operation.
Therefore, every $H$ is a sequential history, and for each history, \(\prec_{H}\) is total order.
Thus, the message media is an atomic object.
Because atomicity is a local property the whole of the message media is also atomic (see Theorem 1 in \cite{Herlihy:1987}).
The message media with the enqueue and dequeue operations is an atomic object.
Thereby, every histories of events for the message media is complete.
%
%%% SYNCHRONIZATION
%
\subsection{Synchronization}
Synchronization in \NHK starts at an output action and terminates at an input action.
Output action $a$ is an invocation \(\inv(a)\), and input action is a response \(\res(a)\).
Partial order on channels \(a\prec_H b\) is that for channel \(a, b\), \(a\prec_H b\) if \(\res(a)\) precedes \(\inv(b)\) in $H$.
Each action is implemented by a sequence of events on the above bounded FIFO buffer: \(\inv(a)\equiv\inv(\enq(v))\res(\enq(v))\) and \(\res(a)\equiv\inv(\deq())\res(\deq())\).
We show that the implementation is correct.

%The specification of concurrent objects in \NHK leads the following axioms.
The following axioms provide the semantics of operations on channel.
  \begin{axiom}[Output Action]\label{ax:output}
    \begin{displaymath}
\{\length(ch)=0\}\inv(a)\{\length(ch)=1\}
    \end{displaymath}
  \end{axiom}
  \begin{axiom}[Input Action]\label{ax:input}
    \begin{displaymath}
\{\length(ch)=1\}\res(a)\{\length(ch)=0\}
    \end{displaymath}
  \end{axiom}
where \(\length(ch)\) is the number of messages on a channel.

For any history $H$, \(\inv(a)\) is not contiguous to other output action \(\inv(a)\).
For example, if events \(\inv(a(v))\), \(\inv(a(v'))\), \(\res(a(v))\), \(\res(a(v'))\) lie within $H$ then 
\(\inv(a(v))\res(a(v))\inv(a(v'))\linebreak\res(a(v'))\), and \(\inv(a(v'))\res(a(v'))\inv(a(v))\res(a(v))\) are acceptable.
But, \(\inv(a(v))\inv(a(v'))\linebreak\res(a(v'))\res(a(v))\), and \(\inv(a(v'))\inv(a(v))\res(a(v))\res(a(v'))\) are not acceptable.
  \begin{lemma}\label{lm:seq}
An invocation \(\inv(a)\) for channel $a$ does not contiguous to \(\inv(a)\), and also a response \(\res(a)\) does not contiguous to \(\res(a)\).
  \end{lemma}
  \begin{proof}
Describe a sequential history $H$ for channel $a$.
\(\inv(a)\) is partial.
If \(\length(a)=1\) then the invocation is blocked.
From \axref{ax:output}, if \(\length(a)=0\) then \(\length(a)=1\) after \(\inv(a)\) occurs.
From \axref{ax:input}, \(\res(a)\) is invoked only if \(\length(a)=1\).
If \(\length(a)=0\) then an response of \(a\) is blocked.
Thereby, for any history $H$, $H$ is sequential.
Thus, \(\inv(a)\) (\(\res(a)\)) is not contiguous.
\QED
  \end{proof}
\lmref{lm:seq} stats that all history must be sequential.
The opposite of \lmref{lm:seq}, i.e. there are no contiguous invocations in a sequential history, is explicit by the definition of sequential history.
  \begin{theorem}\label{th:onetoone}
One output action corresponds with one input action, and one input action corresponds with one output action.
  \end{theorem}
  \begin{proof}
Pick a derivation \(\langle S,P\rangle\in Poss_m\) showing that $H$ is linearizable.
From \Lmref{lm:seq} \(\res(a)\mbox{ (is an input action)}\) is contiguous to \(\inv(a)\mbox{ (is an output action)}\), and \(\inv(a)\) is contiguous to \(\res(a)\) on $S$.
From \axref{ax:closure} Closure, if \(\inv(a)\in P\), then \(\langle S\inv(a)\res(a), P-\{\inv(a)\}\rangle\in Poss_m\).
Thus, all output action has a matching input action, and all input action has a matching output action.
\QED
  \end{proof}
\thref{th:onetoone} implies the following theorem.
  \begin{theorem}
No value is written twice, and no value is read twice.
  \end{theorem}
  \begin{proof}
From \lmref{lm:seq} all history is sequential.
From \thref{th:onetoone} subhistory \(\linebreak\inv(a(v))\inv(a(v))\) is not invoked.
A subhistory \(\res(a(v))\res(a(v))\) is also invoked.
Thus, same values are not written into a channel and read from a channel.
\QED
  \end{proof}
  \begin{theorem}\label{th:notvanish}
If an invocation \(\inv(a(v))\) precedes \(\inv(a(v'))\) and \(\res(a(v'))\) has occurred, then \(\res(a(v))\) must precede \(\inv(a(v'))\).
  \end{theorem}
  \begin{proof}
Pick a derivation \(\langle S,P\rangle\in Poss_m\) showing that $H$ is linearizable.
From \thref{lm:seq}, \(\res(a(v))\) must precedes \(\inv(a(v'))\), and must adapt \axref{ax:closure} for \(\inv(a(v))\) and \(\res(a(v))\) in $S$.
Thus, $v$ on channel $a$ by \(\res(a(v))\) does not vanish until \(\res(a(v))\) is invoked.
\QED
  \end{proof}
\Thref{th:notvanish} implies that messages do not spontaneously vanish form a channel.
  \begin{theorem}
If a response \(\res(a)\) is invoked then \(\inv(a)\) has been invoked before \(\res(a)\) and \(\res(a)\) does not precede \(\inv(a)\).
  \end{theorem}
  \begin{proof}
Pick a derivation \(\langle S,P\rangle\in Poss_m\) showing that $H$ is linearizable.
\(\res(a)\) occurs at $m$ in $H$.
From \axref{ax:response} Response, 
\(\{\langle S,P\rangle\in Poss\mbox{ and }\inv(op)\not\in P\mbox{ and }\res(op)=\last(S)\}\res(op)\{\langle S,P\rangle\in Poss'\}\).
$H$ is legal only if \(\inv(a)\) occur at \(i(<m)\).
\axref{ax:closure} application is included.
Then, for \(i\leq j\leq m\), \(\langle S',P'\rangle\in Poss_j\) and \(\inv(a)\in P'\).
Also, \(\langle S'\inv(a)\res(a),P'-\{\inv(a)\}\rangle\in Poss_j\).
Thus, \(\res(a)\) does not precede \(\inv(a)\).
\QED
  \end{proof}

Channels in \NHK are implemented by queue.
Each output action is implemented by \(\enq\) operation on queue, and each input action is implemented by \(\deq\) operation.
A history is an event sequence interleaved actions with operations of the implementation.

An implementation is correct if for every history $H$ \(H|a\) is linearizable.
Let $H$ be a interleaved history.
We focus on showing that for all \(H|m\)% \(0\leq\length(m)\leq 1\) and 
  \begin{displaymath}
\langle S_m,P_m\rangle\in Poss_{H|m}\Rightarrow\langle S_{a},P_{a}\rangle\in Poss_{H|a}.
  \end{displaymath}

We define an abstract function: \({\cal A}(m):M\rightarrow Ch\) so that it maps each state of the implementation to a state of an abstract data.
$M$ is a set of states of queue and $Ch$ is a set of states of channel.
  \begin{displaymath}
{\cal A}(m)=\{a|\,(m=a=[v])\vee(m=a=\emptyset)\},
  \end{displaymath}
The order of items in buffer does not need because the queue implementation must satisfy \thref{th:bound} \(0\leq\length(m)\leq 1\).

  \begin{theorem}
A transmission via action is atomic.
  \end{theorem}
  \begin{proof}
Association between a message media $m$ and a channel $a$
    \begin{eqnarray*}
\inv(a(v))&\equiv&\inv(\enq(v))\res(\enq(v)),\\
\res(a(v))&\equiv&\inv(\deq(v))\res(\deq(v)).
    \end{eqnarray*}
Then, by \axref{ax:enque} and \axref{ax:deque}
  \begin{displaymath}
\{{\cal A}(m)=\emptyset\}[\inv(a(v) (=\inv(\enq(v))/\res(\enq(v)))]\{{\cal A}(m)=[v]\}
  \end{displaymath}
and
  \begin{displaymath}
\{{\cal A}(m)=[v]\}[\res(a(v) (=\inv(\deq(v))/\res(\deq(v)))]\{{\cal A}(m)=\emptyset\mbox{ and }v=\res(a(v))\}
  \end{displaymath}
These sequences satisfy \axref{ax:output} and \axref{ax:input}.

We need to show that if \(H|m\) is linearizable then \(H|a\) is also linearizable.
It suffices to show that \({\cal A}(m)\) is included in a set of results which \(S_a\) causes.
Pick \(\langle S_m,P_m\rangle\in Poss_{H|m}\).
If the last inference is \axref{ax:closure} for \(\enq(v)\), then the later events of \(S_m\) are \(\inv(\enq(v))\res(\enq(v))\), and the last event of \(H|a\) is \(\inv(a(v))\).
Also \(m=[v]\), so \({\cal A}(m)=[v]\).
At this moment \(\langle S_{a},P_{a}\rangle\in Poss_{H|a}\) and \(\inv(a(v))\in P_{a}\).
By \thref{th:bound} \(\inv(\deq(v))\res(\deq(v))\) is contiguous to \(\inv(\enq(v))\res(\enq(v))\).
Then, \(H|a\,\res(a(v))\) and \(S_a\,\inv(a(v))\res(a(v))\), thereby \(a=\emptyset\) or \([v]\).
Therefore \({\cal A}(m)\in\{\emptyset, [v]\}\).

Moreover, if the last inference is \axref{ax:closure} for \(\deq(v)\), then the later events of \(S_m\) are \(\inv(\deq(v))\res(\deq(v))\), and the last event of \(H|a\) is \(\res(a(v))\).
Also \(m=\emptyset\), so \({\cal A}(m)=\emptyset\).
At this moment \(\langle S_{a},P_{a}\rangle\in Poss_{H|a}\), thereby \(a=\emptyset\).
Therefore \({\cal A}(m)\in\{\emptyset\}\).

By \thref{th:bound} \(\inv(\enq(v'))\res(\enq(v'))\) is contiguous to \(\inv(\deq(v))\res(\deq(v))\).
Thus \({\cal A}(m)\) is included in a set of states which linearization cause.
\QED
  \end{proof}
%
%%% SYNTAX
%
\section{Syntax of Model Description Language}
\subsection{Primitive Type}
RCCS has two types, integer and string.
Operator {\tt +,-,/,*} are defined over these types.
\subsection{Special Actions and Processes}
Action {\tt key} and {\tt display} are special actions. 
{\tt key} is used as an input action corresponding to the standard input, and {\tt display} is used as an output action corresponding to the standard output.
{\tt accept} is used to represents accept states of an automaton produced from a given LTL formula in verification mode.
Those special actions distinguish between upper letters and lower letters.

Process \(\ZERO\) and \({\mathop{\mathrm{STOP}}\nolimits}\) are a special process that means do nothing, not terminate the whole.
\NHK uses a special process {\tt INIT\_STATE} in verification mode.
The process means an initial state of an automaton for a LTL formula given by users.
{\tt ABORT} terminates the whole process for an automaton, but users cannot use in a model.
Those special processes do not distinguish between upper letters and lower letters.
\subsection{Scope}
In expression (define P (x) body), the scope of x becomes body.
In expression (\bijection{a}(x)\(\colon\) body), the scope of x becomes body.

Unfortunately, we use dynamic binding.
In future, we will fix it.
\subsection{Syntax of the Description Language}\label{sec:RCCSsyntax}
\input{ss02-grm}
\subsection{Sorts and Derivatives of Processes}
We make the notion of sort which is a little difference from syntactic sort in \cite{mil:book}.
If actions of a process \(P\) and all its derivatives
  \begin{displaymath}
    \begin{array}{rcl}
\sort{\ZERO}&=&\emptyset\\
\sort{a\colon P}&=&\{a\}\cup\sort{P}\\
\sort{\sim a\colon P}&=&\{\sim a\}\cup\sort{P}\\
\sort{P\mbox{++}Q}&=&\sort{P}\cup\sort{Q}\\
\sort{P\|Q}&=&\sort{P}\cup\sort{Q}\\
\sort{\mbox{if}\ b\ P\ Q}&=&\sort{P}\cup\sort{Q}\\
\sort{A}&=&\sort{P} \mbox{{\tt if} $A\procdef P$}
    \end{array}
  \end{displaymath}
We distinguish names and co-names, and the observation of pairs of matching actions is possible because it is used to determine a next transition of the entire of processes.

We make the notion of syntactic derivative of sort \(\sort{P}\) which is used in the definition of operational semantics.
All derivatives lie in \(\sort{P}\) of \(P\) is syntactic immediate derivatives.
Describing an action sequence \(\alpha_1,\cdots,\alpha_n\) in which each element is an element of \(\sort{P}\) of \(P\), we call a process of the sequence
 and a set of them writes \(\derivative{P}\).
\(\derivative{\ZERO}\) is \(\{\ZERO\}\).
\subsection{RCCS Operational Semantics}\label{sec:OPERATINAL_SEMANTICS}
\input{manual-sem}
\section{Coroutine-Like Sequencing}
An important application of coroutine is discrete event simulation, where coroutine may be used to simulate parallel processes within the framework of a sequential program.
\section{Syntax of Formulae}
We use LTL to describe goal properties of processes.
We first assume that a trace has initial states and is a finite sequence of states.
We write the length of trace \(\sigma=s_0\,s_1\,\cdots\,s_n\) to \(|\sigma|\) in which \(|\sigma|\) is \(n+1\).
We write the suffix of \(\sigma=s_0\,s_1\,\cdots\,s_i\,\cdots\,s_n\) starting at \(i\) as \(\suffix{\sigma}{i}=s_i\,\cdots\,s_n\), and the \(i^{\mbox{th}}\) state as \(\sigma^i\).

We assume a vocabulary \(x,y,z,\cdots\) of variables for data values.
For each state, variables are assigned to a single value.
A state formula is any well-formed first-order formula constructed over the given variables.
Such state formulas are evaluated on a single state to a boolean value.
If the evaluation of state formula \(p\) becomes true over \(s\), then we write \(s\lsquarebracket p\rsquarebracket=\true\) and say that \(s\) satisfies \(p\), where $\true$ and $\false$ are truth values, denoting \(true\) and \(false\) respectively.
Let $\varphi$ and $\psi$ be temporal formulas, a temporal formula is inductively constructed as follows:
  \begin{itemize}
\item a state formula is a temporal formula,
\item the negation of a temporal formula \(\neg\varphi\) is a temporal formula,
\item \(\varphi\vee\psi\) and \(\varphi\wedge\psi\) are temporal formulas, and
\item \(\ltlbox\,\varphi\), \(\ltldiammond\,\varphi\), \(\ltlnext\,\varphi\), and \(\varphi\ltluntil\psi\) are temporal formulas.
  \end{itemize}

We provide the formal syntax with BNF notation.
\input{manual-ltlgrm}
\section{Semantics of Property Description Language}
We next define two semantics of temporal formulas over a finite trace according to \cite{Eisner:2003}.
If trace \(\sigma\) satisfies property \(\varphi\), then we write \(\sigma\models\varphi\).
\subsection{Strong Semantics}
Furthermore,
  \begin{itemize}
\item if $p$ is a state formula, then \(\sigma\models p\) iff \(\sigma^0\lsquarebracket p\rsquarebracket=\true\) and \(|\sigma|\neq 0\),
\item \(\sigma\models\neg\varphi\) iff \(\sigma\not\models\varphi\),
\item \(\sigma\models\varphi\vee\psi\) iff \(\sigma\models\varphi\) or \(\sigma\models\psi\),
\item \(\sigma\models\varphi\wedge\psi\) iff \(\sigma\models\varphi\) and \(\sigma\models\psi\),
\item \(\sigma\models\ltlbox\varphi\) iff for all \(0\leq i<|\sigma|\), \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltldiammond\varphi\) iff there exists \(0\leq i<|\sigma|\) such that \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltlnext\varphi\) iff \(\sigma'\models\varphi\) where \(\sigma'=\sigma\) if \(|\sigma|=1\) and \(\sigma'=\suffix{\sigma}{1}\) if \(|\sigma|>1\),
\item \(\sigma\models\varphi\ltluntil\psi\) iff there exists \(0\leq k<|\sigma|\) s.t. \(\sigma\models\psi\) and for all \(j<k\), \(\sigma\models\varphi\).
  \end{itemize}

A formula \(\varphi\) is satisfiable if there exists a sequence \(\sigma\) such that \(\sigma\models \varphi\).
Given set of traces $T$ and formula \(\varphi\), \(\varphi\) is valid over $T$ if for all \(\sigma\in T\), \(\sigma\models\varphi\).
\subsection{Weak Semantics}
Furthermore,
  \begin{itemize}
\item if $p$ is a state formula, then \(\sigma\models p\) iff \(\sigma^0\lsquarebracket p\rsquarebracket=\true\) or \(|\sigma|=0\),
\item \(\sigma\models\neg\varphi\) iff \(\sigma\not\models\varphi\),
\item \(\sigma\models\varphi\vee\psi\) iff \(\sigma\models\varphi\) or \(\sigma\models\psi\),
\item \(\sigma\models\varphi\wedge\psi\) iff \(\sigma\models\varphi\) and \(\sigma\models\psi\),
\item \(\sigma\models\ltlbox\varphi\) iff for all \(0\leq i<|\sigma|\), \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltldiammond\varphi\) iff there exists \(0\leq i<|\sigma|\) such that \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltlnext\varphi\) iff \(\sigma'\models\varphi\) where \(\sigma'=\sigma\) if \(|\sigma|=1\) and \(\sigma'=\suffix{\sigma}{1}\) if \(|\sigma|>1\),
\item \(\sigma\models\varphi\ltluntil\psi\) iff there exists \(0\leq k<|\sigma|\) s.t. \(\sigma\models\psi\) and for all \(j<k\), \(\sigma\models\varphi\).
  \end{itemize}
%
%%% RELATIONSHIPS BETWEEN MODELS AND FORMULAE
%
\section{Relationships between Models and Formulae}
In this section, we describe the relationship between algebraic models and LTL formulas.
The modeling language enables us to pass values via input prefix \(\alpha(e)\) and output prefix \(\bijection{\alpha}(x)\) with the same name.
The execution of \(\alpha(e)\) produces  value \(v\) of \(e\), and  the execution of \(\bijection{\alpha}(x)\) causes a single assignment to \(x\).
Furthermore, the execution of two actions causes atomic assignment \(x \colon = v\), that is, communication between two agents produces a new state by changing the values of the variables.
This is similar to the first paragraph in Section~3.3 of \cite[page 290]{lamport84hoare}.

This atomic assignment changes states, and  we represent the change as \(s[v/x]\), which denotes a change in the values of \(x\) in \(s\) to \(v\).
A state is a mapping from variables to values.
Assuming that \(\tt \Var_E\) is a set of variables that appears in prefixes in agent \(E\) with range \(\tt V\), \(s\colon \Var_E\rightarrow {\tt V}\).
For example, the evaluation \(s\lsquarebracket x=y\rsquarebracket\) of \(x=y\) at \(s\) becomes \(s\lsquarebracket x\rsquarebracket=s\lsquarebracket y\rsquarebracket\), and at \(s[v/x]\), \(s[v/x]\lsquarebracket x\rsquarebracket=s[v/x]\lsquarebracket y\rsquarebracket\), i.e., \(v=s[y]\).

Therefore, communication between agents produces a sequence of assignments, which then produces a sequence of state changes called a trace.
Let a set of traces produced by agent \(E\) be \(T\).
If for all traces \(\sigma\in T\), \(\sigma\models\varphi\), then we state that \(\varphi\) is valid over \(E\) and write \(E\models\varphi\).
%
%%% TRANSITION OF AUTOMATA
%
\subsection{Transition of Automata}
A LTL formula by which a property of a model is given transforms to a \buchi automaton.
A \buchi automaton $m$ contains of five components:
  \begin{itemize}
\item A finite set of states, denoted $Q$.
\item A finite set of input symbols, denoted $\Sigma$.
\item A transition function $\delta$ that takes a state and an input symbol, and returns a next state.
If $q$ is a state, and $s$ is an input symbol, then \(\delta(q,a)\) returns state $p$.
\item A start state $q_0$ is a state in $Q$.
\item A set of accepting states $Q_{\infty}$ is a subset of $Q$.
  \end{itemize}
In this paper, an input symbol becomes a state of a model.
We talk about an automaton $m$ in \emph{five-tuple} notation: \((Q,\Sigma,\delta,q_0,Q_{\infty})\).

Now, we need to make the notion of the language that an automaton accepts.
To do this, we define an extended transition function.
The extended transition function constructed from $\delta$ is called \(\hat{\delta}\).
We define \(\hat{\delta}\) by induction on the length of an input string $\sigma$, as follows:
  \begin{displaymath}
\hat{\delta}(q,\sigma)=\left\{
      \begin{array}{ll}
q & \mbox{if \(|\sigma |=0\)}\\
\delta(\hat{\delta}(q,\sigma^{..n-1}),\sigma^{n}) & \mbox{if \(0<|\sigma |<\omega\)}.
      \end{array}
\right.
  \end{displaymath}
We define the language \({\cal L} (m)\) of automaton $m$.
Let \(\INF(\rho)\) be a set of automaton states that appear infinitely often in while reading $\sigma$,
then $\sigma$ is accepted by $m$ if and only if \(\INF(\rho)\cap Q_{\infty}\neq\emptyset\).
Thus,
  \begin{displaymath}
{\cal L}(m)=\{\sigma\mid \rho^0=q^0, \forall i\colon\rho^i=\hat{\delta}(q_0,\sigma^{..i})\mbox{, and }\INF(\rho)\cap Q_{\infty}\neq\emptyset\}.
  \end{displaymath}

\(\eta\) depends on weak or strong semantics.
In weak semantics, \(\eta\) is \(q\) that is regarded as an element of \(Q_{\infty}\).
In strong semantics, \(\eta\) is \(\Lambda\), where \(\Lambda\) is inconsistency.
%
%%% CORRESPONDENCE
%
\subsection{Correspondence between Models and Formulae}\label{sec:CorrespondenceBtweenModelsAndFormulae}
We describe a correspondence between a model and a \buchi automaton of a formulae of a property which the model are required.
The correspondence is expressed with Hoare triple: \{p\}$\alpha$\{q\},
where $p$ and $q$ are boolean predicates, and $\alpha$ is an action which a model performs.
To show that a program \(\pi\) satisfies $m$, we demonstrate a correspondence between $m$ and \(\pi\).
We define a correspondence invariant \(C_i\) for each state \(q_i\).
the correspondence invariant \(C_i\) is a predicate that holds on a model state $s$ if an automaton $m$ enters an automaton state \(q_j\) if there exists a history containing program state $s$ and $m$ is transformed from \(q_i\) into \(q_j\) by reading $s$.

We formally define \emph{correspondence invariant} by induction \cite{Alpern:1989}.
\begin{theorem}[Correspondece Basis]\label{th:CorrBasis}
  \begin{displaymath}
\forall j\colon q_j\in Q\mbox{ and }(Init_{\pi}\wedge T_{0j})\Rightarrow C_j,
  \end{displaymath}
where \(Init_{\pi}\) is the initial states of model \(\pi\).
\end{theorem}
\begin{theorem}[Correspondece Induction]\label{th:CorrInd}
  \begin{displaymath}
\forall \alpha\colon\forall i\colon\alpha\in A\cup\bijection{A}\mbox{ and }q_i\in Q\mbox{ and }
\{C_i\}\alpha\{\wedge_{q_j\in Q}(T_{ij}\Rightarrow C_j)\}.
  \end{displaymath}
\end{theorem}

In order to establish that model $\pi$ satisfies property $p$, we must show that every history $\sigma$ of $\pi$ accepts by $m$ for a property.
There are two ways that $m$ fails to accept a history \(\sigma\) of $\pi$:
  \begin{enumerate}
\item $m$ attempts an undefined transition when reading \(\sigma\).
\item $m$ never enters an accepting state after some finite prefix of \(\sigma\).
  \end{enumerate}
Thus, it suffices that (1) and (2) are impossible.
Two obligations ensure that (1) is impossible.
First, we must show that $m$ can make some transition from its start state upon reading the first state in a history.
  \begin{theorem}[Transition Basis]
    \begin{displaymath}
Init_{\pi}\Rightarrow\vee_{j}(q_j\in Q\mbox{ and }T_{0j})
    \end{displaymath}
  \end{theorem}
Second, we must show that $m$ can always make a transition upon reading subsequent states in a history.
If $m$ is in state \(q_i\) then the model state read by $m$ satisfies a correspondence invariant \(C_i\).
To avoid an undefined transition, any atomic action \(\alpha\) that is then executed must transform the model state so that one of the transition predicates \(T_{ij}\) emanating from \(q_i\) holds.
This is guaranteed by 
  \begin{theorem}[Transition Induction]
For all \(\alpha (\in {\cal A})\), and for all $i$ \((q_i\in Q)\),
    \begin{displaymath}
\{C_i\}\alpha\{\vee_{j:q_j\in Q}T_{ij}\}
    \end{displaymath}
  \end{theorem}

Finally, we present conditions to ensure that $m$ cannot reject \(\sigma\) by failing to enter accepting state infinitely often (scenario (2) above).
A set $Q'$ of automaton states is a subset of $Q$ that contains no accepting states.
Let \(Q_{\INF}\) be a set of states that infinitly often appear on a history of a program,
if $m$ reject a history then \(Q_{\INF}\) restricts to $Q'$.
To ensure that \(Q_{\INF}\) of a history is not restricted to $Q'$, we construct a variant function
 \(v_k:Q\times S\rightarrow N\), where $N$ is Natural numbers.
When \(v_k(q,s)=0\), then $q$ is in $Q'$.
  \begin{theorem}[Knot Exit]
    \begin{displaymath}
\forall q_i\in Q'\colon (v_k(q_i,s_i)=0)\Rightarrow \neg C_i.
    \end{displaymath}
  \end{theorem}
  \begin{theorem}[Knot Variance]
For all \(\alpha (\in {\cal A})\), and for all \(q_i\in k\),
    \begin{displaymath}
\{C_i\wedge0<v_k(q_i)=V\}\alpha\{\vee_{j:q_j\in Q}T_{ij}\wedge C_j\Rightarrow v_k(q_j)<V\}
    \end{displaymath}
  \end{theorem}
We show later that those theorems hold in \NHK.
%
%%% Proving Safety Properties
%
\subsection{A Proof Systems for The Modelling Language}\label{sec:ProofSystems}
A model \(\pi\) written by our model language has the form: \(\pi=\pi_1\|\cdots\|\pi_n\).
Processes synchronize and communicate using input actions and output actions.
For a channel \(a\), a value of \(exp\) and a variable \(var\), execution of an output action
  \begin{displaymath}
\bijection{a}(exp)
  \end{displaymath}
causes the transfer of the value of \(exp\), and execution of a matching input action 
  \begin{displaymath}
a(var)
  \end{displaymath}
which some other process performs, causes receive from channel \(a\).
an input action is delayed until some matching output action.

Two matching actions are executed as an atomic action which causes an assignment to \(var\):
  \begin{displaymath}
var\,=\,exp.
  \end{displaymath}
The atomic assignment which consists of two actions \(\bijection{a}\) and \(a\) occurs as a free-standing statement.
We regard the atomic assignment above as a fragment of models.

The set of atomic actions which make up program \(\pi\) is denoted \(\alpha[\pi]\).
If \(\pi\) is composed of fragments \(\pi_1,\cdots,\pi_n\) then:
  \begin{displaymath}
\alpha[\pi]=\alpha[\pi_1]\cup\cdots\cup\alpha[\pi_n].
  \end{displaymath}
If \(\pi\) is clear by context then \(\pi\) is omitted.

The modelling language guarantees matching semantics between input and output actions.
All change of variables appears at execution of action, not in body.
For example, consider \(P_1\|P_2\) in which each process is defined as follows:
  \begin{displaymath}
    \begin{array}{lcl}
P_1&=&a(x)\colon\ZERO\mbox{++}\bijection{a}(1)\colon a(x)\colon\ZERO,\\
P_2&=&\bijection{a}(2)\colon\ZERO\mbox{++}a(z)\colon\bijection{a}(z+1)\colon\ZERO.
    \end{array}
  \end{displaymath}
It does not produce a change of variables except input-output pairs.
If changes except the pairs are abvairable, axiom Communication is meaningless.

We present the following proof rules for all possible constructs of processes, according to \cite{Apt:1980}.
  \begin{displaymath}
\infer[\mbox{Input}]{\{p\}a(x)\{q\}}
                    {}
  \end{displaymath}
This axiom corresponds to A.1 in \cite{Apt:1980}.
The post assertion in this axiom will be checked against a corresponding output action with which some process cooperates.
  \begin{displaymath}
\infer[\mbox{Output}]{\{p\}\bijection{a}(y)\{q\}}
                    {}
  \end{displaymath}
This axiom may look strange since it has no side-effect.
We introduce this axiom corresponding to A.2' in \cite{Apt:1980} because the modelling language allows output actions without matching inputs.
Communication \(\{p\}\alpha(x)\colon P\ \|\ \bijection{\alpha}(y)\colon Q\{q\}\) does not derives an arbitrary predicate.
The form of $q$ restricts to the formula of \(\{p\}\alpha(x)\colon P\ \|\ \bijection{\alpha}(y)\colon Q\{x=y\wedge p\}\) where $x$ is not free in $p$.

Generalizing axiom Output provides the following axiom:
  \begin{displaymath}
\infer[\mbox{Preservation,}]{\{p\}P\{p\}}
                    {}
  \end{displaymath}
if free variables in \(p\) is not changed in execution of \(P\).

Action prefixes mean sequential execution of actions.
This syntactical structure provides the following rule.
  \begin{displaymath}
\infer[\mbox{Sequence}]
      {\{p\}\alpha\colon P\{q\}}
      {\{p\}\alpha\{p'\}&\{p'\}P\{q\}}
  \end{displaymath}

The meaning of the following rule is that the post condition of summation must be established along each possible path.
  \begin{displaymath}
\infer[\mbox{Summation}]{\{p\}P\mbox{++}Q\{q\}}
                        {\{p\}P\{q\}&\{p\}Q\{q\}}
  \end{displaymath}

Subsequently we use the following well-known axioms and proof rules.
  \begin{displaymath}
\infer[\mbox{Zero}]
      {\{p\}\ZERO\{p\}}
      {}
  \end{displaymath}
  \begin{displaymath}
\infer[\mbox{Alternation}]
      {\{p\}[(\mbox{if}\ b\ P_1\ P_2)]\{q\}}
      {\{p\wedge b\}P_1\{q\}&\{p\wedge \neg b\}P_2\{q\}}
  \end{displaymath}
  \begin{displaymath}
\infer[\mbox{Consequence}]
      {\{p\}P\{q\}}
      {p\rightarrow p'&\{p'\}P\{q'\}&q'\rightarrow q}
  \end{displaymath}
  \begin{displaymath}
\infer[\mbox{Conjunction}]
      {\{p\}P\{q\wedge r\}}
      {\{p\}P\{q\}&\{p\}P\{r\}}
  \end{displaymath}
  \begin{displaymath}
\infer[\mbox{Substitution}]
      {\{p\}P\{q\}}
      {\{p[t/z]\}P\{q\}}
  \end{displaymath}
  \begin{displaymath}
\infer[\mbox{Omission}]
      {\{p\}A\{q\}}
      {\{p\}P\{q\}&A\procdef P}
  \end{displaymath}

Using these axioms and rules, we can establish a proof for formulae of a process.
A proof start by the following form:
  \begin{displaymath}
\infer{\{p_1\wedge\cdots\wedge p_n\}P_1\|P_2\|\cdots\{q_1\wedge\cdots\wedge q_n\}}
      {\{p_1\}P_1\{q_1\}&\{p_2\}P_2\{q_2\}&\cdots}
  \end{displaymath}
Each proof cooperates if they help to validate the post-conditions of input-output mentioned in those proofs.
The meaning of this rule is that proofs cooperate to help each other proof to validate the post conditions of input/output actions.
More formally, the proofs of \(\{p_i\}P_i\{q_i\}\) for \(1\leq i\leq n\) cooperate if 
  \begin{enumerate}
\item the assertions used in the proof contain no variables to change in \(P_j\) where \(j\neq i\), and
\item \(\{\mbox{pre}_1\wedge\mbox{pre}_2\}\bijection{a}\colon P\|a\colon Q\{\mbox{post}_1\wedge\mbox{post}_2\}\) holds
whenever \(\{\mbox{pre}_1\}\bijection{a}\colon P\{\mbox{post}_1\}\) and \(\{\mbox{pre}_2\}a\colon Q\{\mbox{post}_2\}\) are taken from the proof of \(\{p_i\}P\{q_i\}\) and \(\{p_j\}Q\{q_j\}\).
  \end{enumerate}
We shall need the following axiom to establish cooperation:
  \begin{displaymath}
\infer[\mbox{Communication}]
      {\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
      {}
  \end{displaymath}

We introduce inference rules for cooperation because they cannot produce proof trees. 
  \begin{displaymath}
\infer[\mbox{Cooperation1,}]{\{p\}a(x)\{p\wedge(x=y)\}}
                    {\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
  \end{displaymath}
and
  \begin{displaymath}
\infer[\mbox{Cooperation2.}]{\{p\}\bijection{a}(y)\{p\wedge(x=y)\}}
                    {\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
  \end{displaymath}

The modelling language in \NHK allows self-communication, for example \((\bijection{a}(1)\colon a(x)\colon\ZERO)\).
Using the system above, we can prove it:
  \begin{center}
    \begin{math}
\infer{\{\Truerm\}\bijection{a}(1)\colon a(x)\colon\ZERO\{x=1\}}
      {\infer{\{\Truerm\wedge\Truerm\}\bijection{a}(1)\colon a(x)\colon\ZERO\{x=1\wedge\Truerm\}}
             {\Truerm\rightarrow\Truerm&
              \infer{\{\Truerm\}\bijection{a}(1)\{\Truerm\}}{}&
              \infer{\{\Truerm\}a(x)\colon\ZERO\{x=1\}}
                    {\infer{\{\Truerm\}a(x)\{x=1\}}
                           {\{\Truerm\}[a(x)\|\bijection{a}(1)]\{x=1\}}&
                     \infer{\{x=1\}\ZERO\{x=1\}}{}}&
              (x=1)\rightarrow(x=1)}}
    \end{math}
  \end{center}
%
%%% Proving Properties
%
\subsection{Proving Safety Properties}
Using axioms and rules in \secref{sec:ProofSystems}, we establish several proofs of assertions in \secref{sec:CorrespondenceBtweenModelsAndFormulae}.
Variables occur in input and output actions present state variables of a model.
Let $\Var=\{x,y, \cdots\}$ be a set of state variables. 
When two processes cooperate through an input action \(a(x)\) and a matching output action \(\bijection{a}(v)\), a state of a model is changed by the assignment \(x:=v\) which is atomic.
The assignment as \(x:=v\) denotes a state change from \(env\) to \(env[v/x]\).

The following explains the correspondence between instruments in \secref{sec:CorrespondenceBtweenModelsAndFormulae} and in the operational semantics in \secref{sec:OPERATINAL_SEMANTICS}.
Correspondence invariant \(C_i\) predicates:
  \begin{itemize}
\item a model changes its state to \(s_i\) and
\item an automaton $m$ reaches to \(q_i\) reading \(s_i\).
  \end{itemize}
A state \(s_i\) can be described by giving values of state variables in \(\Var\).
A valuation is a function that maps variables in \(\Var\) to values in a domain \(D\).
State \(s_i\) corresponds to a valuation.
Environment \(env\) provided by transition within matching communication in a model is also a function that maps variables in \(\Var\) to values in a domain \(D\).
Therefore, we regards an environment \(env_i\) in \NHK interpreter as a state \(s_i\).
We can write a formula that is true on a valuation.
Therefore, we define a formula \(Env_i\) for an environment as follows:
  \begin{displaymath}
Env_i\equiv({\displaystyle\wedge_{i}}(v_i=a_i)).
  \end{displaymath}
\(Env_i\) is equivalent to \(C_i\).
\(Env_0\) is \(\{\Truerm\}\) and corresponds to \(Init_{\pi}\).

Consider a pair of a model state and an automaton state for a property that the model should satisfy.
Let \(\langle env_i,q_i\rangle\) be a pair of a model state and an automaton state.
When the pair exists, \(C_{i}\) clearly holds on the pair.
If a model changes states according to \figref{fig:semRCCS}, \(env_i\) appears in a configuration on the execution history of the model.
In verification mode, \NHK translates a LTL formula to a process expression which has a special constant process as initial state to represent an automaton for the LTL formula.
Each transition of an automaton is indicated with form \(({\tt if}\ (B_i)\ (E_T)\ (E_F))\).
If \(env_j\models B_i\) then the automaton reaches to \(E_T\), otherwise \(E_F\).
\(B_i\) on \(env_j\) is checked when an input and an output action are matched.
The semantics of {\tt if} operator in verification mode are provided as follow:
\begin{center}
  \begin{tabular}{c}
\inference[If(1)]
{(P,env)\trans{[\alpha,\overline{\alpha}]}(P',env') & env'\models B}
{\langle[(P,env),k,ch],({\tt if}\ B\ E_T\ E_F)\rangle\trans{ }\langle[(P',env'),k',ch'],E_T\rangle}
\\\\
\inference[If(2)]
{(P,env)\trans{[\alpha,\overline{\alpha}]}(P,env')' & env'\not\models B&\neg\mbox{is-if}(E_F)}
{\langle[(P,env),k,ch],({\tt if}\ B\ E_T\ E_F)\rangle\trans{ }\langle[(P',env'),k',ch'],E_F\rangle}
\\\\
\inference[If(3)]
{(P,env)\trans{[\alpha,\overline{\alpha}]}(P,env')' & env'\not\models B&\mbox{is-if}(F)}
{\langle[(P,env),k,ch],({\tt if}\ B\ E_T\ E_F)\rangle\trans{ }\langle[(P',env'),k',ch'],\mbox{eval}(E_F,env)\rangle}
  \end{tabular}
\end{center}
where \(\mbox{is-if}(E)\) holds if the most outer operator of \(E\) is {\tt if}.
If {\tt Abort} occurs, \NHK explores other execution paths of a model.

Transition predicate \(T_{ij}\) is derived from transition function \(\delta: (Q\times S)\rightarrow 2^Q\) such that \(q_j\in\delta(q_i,s_j)\).
\(T_{ij}\) holds for all \(s_j\) such that \(q_j\in\delta(q_i,s_j)\).
\(T_{ij}\) holds on \(\langle env_j, ({\tt if}\ B_i\ P_i\ Q_i)\rangle\) if and only if \(env_j\models B_i\).
When the continuation in the configuration contains a closure, then \(env_j=env_j^P\cup env_j^Q\).
If pairs of the same variable name exist then the value of a variable becomes non-deterministic.

We show that \NHK satisfies \thref{th:CorrBasis}.
The predicate depends on \(T_{0j}\) because we assume \(Env_0=\Truerm\).
If \(T_{0j}\) then \(env_j\models B_i\).
\(Env_j\) obviously holds at model state \(s_j\).
Thus, \(C_j\) holds.

\thref{th:CorrInd} is shown by a proof system in \secref{sec:ProofSystems}.
Let \(Env_j\equiv Env_i\wedge(x=y)\) and \(env_j=env_i[x\leftarrow y]\).
We show the proof tree, and then retrieve the following inferences on \(a(x)\colon P\).
  \begin{center}
    \begin{math}
\inference{
  \inference{
    \inference{\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
    {\inference{\{Env_i\}a(x)\{env_j\models B_i\}\\
                  B_i\rightarrow Env_j} {\{Env_i\}a(x)\{Env_j\}}}&
     \inference{\vdots}
     {\{Env_j\}\langle[(P,env_j^P),k',ch'],T_i\rangle\{Env_k\}}&env_j\models B_i}
  {\{Env_i\}\langle[(a(x)\colon P,env_i),k,ch],(\mbox{if}\ B_i\ T_i\ F_i)\rangle\{Env_k\}}&\vdots}
{\{Env_i\}\langle[(a(x)\colon P,env_i^P)\|(\bijection{a}(y)\colon Q,env_i^Q),k,ch],(\mbox{if}\ B_i\ T_i\ F_i)\rangle\{Env_k\}}
    \end{math}
  \end{center}
In addition, we retrieve the following inferences on \(\bijection{a}(x)\colon Q\).
  \begin{center}
    \begin{math}
\inference{
  \vdots&
    \inference{\inference{\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
               {\inference{\{Env_i\}\bijection{a}(y)\{env_j\models B_i\}\\B_i\rightarrow Env_j}
                {\{Env_i\}\bijection{a}(y)\{Env_j\}}}&
                   \inference{\vdots}
                   {\{Env_j\}\langle[(Q,env_i^Q),k,ch],T_i\rangle\{Env_k\}}&env_j\models B_i}
   {\{Env_j\}\langle[(\bijection{a}(y)\colon Q,env_i^Q,k,ch]\rangle\{Env_k\}}}
{\{Env_i\}\langle[(a(x)\colon P,env_i^P)\|(\bijection{a}(y)\colon Q,env_i^Q),k,ch],(\mbox{if}\ B_i\ T_i\ F_i)\rangle\{Env_k\}}
    \end{math}
  \end{center}
We can ignore the inferences of P and Q because we now discuss the one step of matching actions.

We must show that every history of a model is accepted by automaton $m$.
There are two ways that $m$ fails to accept history \(\sigma\) of model \(M\):
  \begin{enumerate}
\renewcommand{\theenumi}{\roman{enumi}}
\renewcommand{\labelenumi}{(\roman{enumi})}
\item a model attempts an undefined transtion when reading \(\sigma\), or \label{line:UndefTrans}
\item a model never reachs to an accepting state after some finite prefix of \(\sigma\). \label{line:NeverAccept}
  \end{enumerate}
In order to prove that every history of \(M\), it suffices to show that (\ref{line:UndefTrans}) and (\ref{line:NeverAccept}) are impossible.
The above proof tree shows it in addition to the correspondence invariant.
If \(env_j\models B_i\) then \(env_j\) at which \(B_i\) holds exists.
By the definition of \(Env_j\), \(Env_j\) clearly holds at \(env_j\).
Therefore, if \(env_j\models B_i\) then \(env_j\models Env_j\).
To avoid an undefined transition, an automaton for a property must transform from \(q_i\) to \(q_j\).
The one of conditions must holds at model state \(env_j\) that the execution of a pair of matching actions produces from \(env_i\).
Therefore, if \(env_j\models Env_j\) then \(env_j\models B_i\).
Thus, any state of a model relates to a state of an automaton that stay in a range while reading a history of a model.

We derive conditions to ensure that $m$ cannot reject a history by (\ref{line:NeverAccept}).
To do this, we define a relation $\ll$ on a set of automaton states.
\(q_{i-1}\ll q_n\) if for each i from 1 to n, there is $n$ such that \(\delta(q_{i-1},s)=q_{i}\).
Clearly, \(\ll\) is a well-founded relation on a set of automaton states.
Since \(\ll\) is well-founded, the following function of which the range is an initial segment of ordinals exists:
  \begin{displaymath}
\rho(q_j)=\sup\{\rho(q_i)+1\colon q_i\ll q_j\}.
  \end{displaymath}
Assume that a subset \(Q'\) of automaton states contains no accepting states.
Since subset \(Q'\) is well-ordered by \(\ll\), the least element \(q{_\xi}\) of \(Q'\) exists.
If $m$ rejects a history by (\ref{line:NeverAccept}) then there exists a path from \(q_{\eta}\) to \(q_{\xi}\).
We construct a variant function \(v(q_{\eta},s)\) which is zero when \(\rho(q_{\xi})=\rho(q_{\eta})+1\).

A propety $P$ is liveness if and only if;
  \begin{displaymath}
\forall\alpha\in S^*\colon\exists\beta\in S^{\omega}\colon\alpha\beta\models P.
  \end{displaymath}
Get the negation of it,
  \begin{displaymath}
\exists\alpha\in S^*\colon\forall\beta\in S^{\omega}\colon\alpha\beta\not\models P.
  \end{displaymath}
Then, An automaton specifies a liveness property has infinite sequences of automaton states, reading \(\beta\).
In this case, a sequence of automaton states by reading \(\beta\) contains no accepting states.
Let \(Q'\) be a set of automaton states in the sequence.
\(Q'\) has the \(\ll\)-minimal element which is then the least element.
If an automaton accepts a history then the automaton does not enter into \(Q'\).
Thus, let \(q_{\xi}\) be the least element, \(\delta(q_{\eta},s_{\xi})\neq q_{\xi}\) at state \(q_{\eta}\) such that \(\rho(q_{\xi})=\rho(q_{\eta})+1\).
Given \(v(q_{\eta},s)\) with \(\xi-\eta-1\), \(v(q_{\eta},s)=0\Rightarrow\neg C_{\xi}\).
In \NHK, \(v(q_{\eta},env_{\eta})=0\Rightarrow\neg Env_i\).

Since in \NHK, \(s_i\) is \(env_i\), \(C_i\) is \(Env_i\), and \(T_{ij}\) is \(env_j\models B_i\):
  \begin{center}
    \begin{math}
\inference{
  \inference{
    \inference{\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
    {\inference{\{Env_i\}a(x)\{env_j\models B_i\}\\
                  B_i\rightarrow Env_j} {\{Env_i\}a(x)\{Env_j\}}}&
     \inference{\vdots}
     {\{Env_j\}\langle[(P,env_j^P),k',ch'],T_i\rangle\{Env_k\}}&env_j\models B_i}
  {\{Env_i\}\langle[(a(x)\colon P,env_i),k,ch],(\mbox{if}\ B_i\ T_i\ F_i)\rangle\{Env_k\}}&\vdots}
{\{Env_i\wedge 0<v(q_i,env_i)=V\}\langle[(a(x)\colon P,env_i^P)\|(\bijection{a}(y)\colon Q,env_i^Q),k,ch],(\mbox{if}\ B_i\ T_i\ F_i)\rangle\{env_j\models B_i\wedge Env_j\Rightarrow v(q_j,env_j)<V\}}
    \end{math}
  \end{center}
In addition, we retrieve the following inferences on \(\bijection{a}(x)\colon Q\).
  \begin{center}
    \begin{math}
\inference{
  \vdots&
    \inference{\inference{\{\Truerm\}[a(x)\|\bijection{a}(y)]\{x=y\}}
               {\inference{\{Env_i\}\bijection{a}(y)\{env_j\models B_i\}\\B_i\rightarrow Env_j}
                {\{Env_i\}\bijection{a}(y)\{Env_j\}}}&
                   \inference{\vdots}
                   {\{Env_j\}\langle[(Q,env_i^Q),k,ch],T_i\rangle\{Env_k\}}&env_j\models B_i}
   {\{Env_j\}\langle[(\bijection{a}(y)\colon Q,env_i^Q,k,ch]\rangle\{Env_k\}}}
{\{Env_i\}\langle[(a(x)\colon P,env_i^P)\|(\bijection{a}(y)\colon Q,env_i^Q),k,ch],(\mbox{if}\ B_i\ T_i\ F_i)\rangle\{Env_k\}}
    \end{math}
  \end{center}
%
%%% exploring state space
%
%\section{exploring state space}
%
%%% bibliography
%
\bibliographystyle{alpha}
\bibliography{reference}

\end{document}
