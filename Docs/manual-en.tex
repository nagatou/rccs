\documentclass[12pt,a4paper,titlepage]{article}
%%%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{graphicx}
\usepackage{fleqn}
\usepackage{latexsym}
\usepackage{listings}
%%%%% theorem.sty
%\usepackage{amsthm}
%\theoremstyle{definition}
%%%
%%%%% theorem.sty
\usepackage{theorem}
\theorembodyfont{\normalfont}
%
% Proof environment with \QED
%
\makeatletter
\newenvironment{proof}[1][\proofname]{\par
  \normalfont
  \topsep6\p@\@plus6\p@ \trivlist
  \item[\hskip\labelsep{\bfseries #1}\@addpunct{\bfseries.}]\ignorespaces
}{%
  \endtrivlist
}
\newcommand{\proofname}{Proof Sketch}
\makeatother
%%%
\theoremstyle{break}
\newtheorem{definition}{DEFINITION}[section]
\newtheorem{axiom}{AXIOM}[section]
\newtheorem{theorem}{THEOREM}[section]
\newtheorem{lemma}{LEMMA}[section]
\usepackage[inference]{semantic}
\input{style}
%----------------------------------------------------------
\title{\NHK Install Manual and Specification} 
\author{Naoyuki Nagatou\thanks{PRESYSTEMS Inc. Copyright 2014 Naoyuki Nagatou}\\%
\small PRESYSTEMS Inc.\\[6pt]
\small nagatou@presystems.xyz}
\date{}
%----------------------------------------------------------
\markboth{Copyright 2014 Naoyuki Nagatou}{Copyright 2014 Naoyuki Nagatou}


\begin{document}
  \begin{titlepage}
\maketitle
%
%%% ABSTRACTION
%
\begin{abstract}
\NHK \emph{is a model checking tool developed by us and published according to GPLv3 and later}.

In general, there are two checking processes within the lifecycle of a system.
One is verification of models describing functional specification, 
and the other is testing of real codes implementing the system.
We developed a model checking tool can being used on both processes.
Model checking systematically explores the state space of systems.
The systems are expressed as the model
or real code(or source code) written in programming languages such as C.
There are several model checking tools 
that handle either the models or the real codes,
but not both.
In testing processes of the real codes,
our model checking tool checks both the models and the real codes.
The tool executes the binary code on GDB,
then examines a composition with the model from which the portions of 
the model that correspond to the code being executed
have been eliminated.
A state space of the real code is a set of GDB's breakpoints corresponding to
actions to communicate between the eliminated portion and others,
so the model is written in a modeling language based on process algebra.
This tool enables the re-use of the same model that was used in verification processes.
\end{abstract}
  \end{titlepage}
\tableofcontents
\newpage
\section{Installation}
  Compiling those files needs glib-1.2. You need to install it before doing this.
Please refer the manual to install glib-1.2.
  \begin{enumerate}
\item After installing glib-1.2, \\
    \verb|>| tar -xvzf rccs.tar.gz
\item type the following\\
    \verb|>| cd rccs/src
\item  similarly,\\
    \verb|>| make rccs
  \end{enumerate}
If you cannot compile then please edit the make file for your configuration.
Perhaps, glib is installed into a different place.
\section{Run-Time Options}
\NHK allow us to use the following option to control the behaviour of \NHK.
  \begin{quotation}
rccs [-tisq] [-f FORMULA] [-d TARGET [ARGUMENTS]] [-m MODEL].
  \end{quotation}
When you give both -d and -f, then I examine the target in the verification mode, and give only -f then I verify a given property for a model.
When you don't give both -f and -d, I will run the model in the emulation mode.
%  \begin{quotation}
    \begin{itemize}
\item -t : turns the trace flag on.
\item -f "formula": specifies a formula and moves to verification mode.
\item -d "target" ["arguments"]: specifies a debugging program and moves to collaboration mode.
%\item -m "model" : specifies a source file written in RCCS (Not Yet).
%\item -q : changes channels in RCCS to queue buffer.
%\item -s : changes channels in RCCS to stack buffer (Default).
\item -i : provides the interactive execution mode.
\item -g : stronG view of the semantics (default).
\item -k : weaK view of the semantics.
    \end{itemize}
%  \end{quotation}
%
%%% COMMUNICATION
%
\section{Communication}
Let us try to see a message media for the transmission of information in \NHK.
One of implementations of message medias is a bounded buffer.
The message media discipline is:
  \begin{itemize}
\item The channel is a bidirection channel and a bounded buffer whose size is 1.
\item A sender may always send a message, provided the buffer is not full.
\item If the buffer is full then a sender is blocked.
\item A receiver may always receive a message, provided the buffer is not empty.
\item If the buffer is empty then a receiver is blocked.
  \end{itemize}
The bounded buffer in \NHK takes one message at a time.
We call this buffer a register, and operations write/read.
If a buffer is full/empty then write/read operation is blocked.
To simplify the description, we consider that the buffer is FIFO.
Moreover, communication is connected by bidirectional channel.

A concurrent object is defined by a set of operations and a specification that defines the meaning of the object.
Message channels in \NHK has the following specification.
  \begin{itemize}
\item One output action matches to one input action.
\item One input action match's to one output action.
\item Every value read is written, but not overwritten.
\item The first action of a history is an output action.
\item An output action write values to a channel, provided a empty channel.
\item An input action read values from a channel, provider a channel is not empty.
\item No value is written twice.
\item No value is read twice.
  \end{itemize}

Moreover, the shared object has atomicity property (linearizability).
A contiguous occurrence of the matching actions is an atomic communication among matching actions.
A pair of an input action and an matching output action in a sequential history atomically behaves.
%
%%% LINEARIZABILITY
%
\subsection{Atomicity Consistency (Linearizability)}
Sequences of actions in \NHK has linearizability property that Herlihy and Wing define in \cite{Herlihy:1987}.
Linearizability requires each operation should appear to ''take effect'', and the order of nonconcurrent operations should be preserved.

An execution on concurrent objects is modeled by a history, which is a finite sequence of operation invocation and response events.
An action involves two operations to communication media.
One is to write messages to the media as an output action, and another is to read messages from it as an input action.
Each operation is a pair consists of an invocation event and the matching response event.
An invocation of an operation is written as \(\inv(op)\), and also an response event is written as \(res(op)\).
  \begin{definition}[Sequencial History]
A history $H$ is sequential if:
    \begin{itemize}
\item The first event of history $H$ is an invocation of an action.
\item Each invocation event, except possibly the last, is immediately followed by a matching response event.
\item Each response event, except possibly the last, is immediately followed by an invocation event.
    \end{itemize}
  \end{definition}
Let $a$ be any process \(P_i\) or any object \(X\).
\(H|a\) denotes the projection of $H$ on $a$.
Two histories are equivalent if for every process \(P_i\), \(H|P_i=H'|P_i\).
A history is well-formed if a projection on each process is sequential.
All histories considered in this paper are assumed to be well-formed.

A history $H$ induces an irreflexive relation \(\prec_{H}\) on a set of operations.
\begin{definition}[Partial Order on Oeprations]
  \begin{displaymath}
op_1\prec_{H}op_2\mbox{ if }\res(op_1)\mbox{ precedes }\inv(op_2)\mbox{ in }H.
  \end{displaymath}
\end{definition}
If $H$ is sequential then \(\prec_{H}\) is total.

The next introduces the condition of linearizability.
\begin{definition}[Linearizability]
There is a sequential history $S$ such that:
  \begin{itemize}
\item history $H$ is equivalent to some legal sequential history $S$,
\item \(\prec_{H}\subseteq\prec_{S}\), and
\item \(\prec_{S}\) is total order.
  \end{itemize}
\end{definition}

Given a linearizable history, there may be more than one linearization.
A possibility for linearization is a pair \(\langle S,P\rangle\), where $S$ is a linearization of a given history and $P$ is a set of pending operations which are not completed to construct $S$.
\(Poss_H\) denotes a set of possibilities for history $H$.
$Poss$ is captured by the following three axioms.
  \begin{axiom}[Closure]\label{ax:closure}
if \(\langle S,P\rangle\in Poss\) then
    \begin{displaymath}
      \begin{aligned}
\forall\inv(op)&\in P.\,\exists\res(op).\,S\inv(op)\res(op)\mbox{ is legal}\\
&\Rightarrow\langle S\inv(op)\res(op),P-\{\inv(op)\}\rangle\in Poss
      \end{aligned}
    \end{displaymath}
  \end{axiom}
The axiom states that if $S$ is a linearization of $H$ , \(\inv(op)\) is a pending invocation in $H$ that is not completed to form $S$, and \(S'=S\inv(op)\res(op)\) is a legal sequential history, then $S'$ is also a linearization of $H$.
  \begin{axiom}[Invocation]
    \begin{displaymath}
\{\langle S,P\rangle\in Poss\}\inv(op)\{\langle S,P\cup\{\inv(op)\}\rangle\in Poss'\}
    \end{displaymath}
  \end{axiom}
Axiom Invocation states that any invocation of $H$ is also a linearization of \(H\inv(op)\).
  \begin{axiom}[Response]\label{ax:response}
    \begin{displaymath}
\{\langle S,P\rangle\in Poss\mbox{ and }\inv(op)\not\in P\mbox{ and }\res(op)=\last(S)\}\res(op)\{\langle S,P\rangle\in Poss'\}
    \end{displaymath}
  \end{axiom}
Axiom Response states that any linearization of $H$ in which the pending \(\inv(op)\) is completed with \(\res(op)\) is also a linearization of \(H\res(op)\).
\(\last(S,A)\) is the response to $A$'s last invocation in the sequential history $S$.
An operation completion decides the order of the operation, and then the invocation of the operation in $P$ on $Poss$ is removed.
%
%%% NHK Message Media
%
\subsection{\NHK Message Media}
The bounded buffer in \NHK takes one message at a time from that message media discipline.
Operation \(\enq\), if the buffer is empty, places a message in the buffer, otherwise it is blocked.
Operation \(\deq\), if the buffer is full, reads a message from the buffer, otherwise it is blocked.
A specification is a set of axioms.
The message media discipline leads the axioms.
$m$ denotes a state of a message media, \([v]\) denotes a queue list, and $v$ is a items in a queue.
  \begin{axiom}[Enqueue]\label{ax:enque}
    \begin{displaymath}
\{m=\emptyset\}[\inv(\enq(v))/\res(\enq(v))]\{m=[v]\}
    \end{displaymath}
  \end{axiom}
  \begin{axiom}[Dequeue]\label{ax:deque}
    \begin{displaymath}
\{m\neq\emptyset\mbox{ and }m=[v]\}[\inv(\deq())/\res(\deq())]\{m=\emptyset\mbox{ and }v=\res(\deq())\}
    \end{displaymath}
  \end{axiom}
The above axioms imply the following \thref{th:bound}.
  \begin{theorem}\label{th:bound}
If $m$ is empty initially then
    \begin{displaymath}
0\leq\mbox{length}(m)\leq 1,
    \end{displaymath}
where \(\length\) provides the number of items in buffer $m$.
  \end{theorem}
  \begin{proof}
Operation \(\enq\), if the buffer is not empty then it is blocked, and \(\deq\), if the buffer is empty then it is blocked.
When \(\length(m)\) is empty initially then \(\length(m)\) is at most 1.
\QED
  \end{proof}

Let $H$ is a history on the message media.
\NHK in current implementation immediately completes each operation.
Therefore, every $H$ is a sequential history, and for each history, \(\prec_{H}\) is total order.
Thus, the message media is an atomic object.
Because atomicity is a local property the whole of the message media is also atomic (see Theorem 1 in \cite{Herlihy:1987}).
The message media with the enqueue and dequeue operations is an atomic object.
Thereby, every histories of events for the message media is complete.
%
%%% SYNCHRONIZATION
%
\subsection{Synchronization}
Synchronization in \NHK starts at an output action and terminates at an input action.
Output action $a$ is an invocation \(\inv(a)\), and input action is a response \(\res(a)\).
Partial order on channels \(a\prec_H b\) is that for channel \(a, b\), \(a\prec_H b\) if \(\res(a)\) precedes \(\inv(b)\) in $H$.
Each action is implemented by a sequence of events on the above bounded FIFO buffer: \(\inv(a)\equiv\inv(\enq(v))\res(\enq(v))\) and \(\res(a)\equiv\inv(\deq())\res(\deq())\).
We show that the implementation is correct.

%The specification of concurrent objects in \NHK leads the following axioms.
The following axioms provide the semantics of operations on channel.
  \begin{axiom}[Output Action]\label{ax:output}
    \begin{displaymath}
\{\length(ch)=0\}\inv(a)\{\length(ch)=1\}
    \end{displaymath}
  \end{axiom}
  \begin{axiom}[Input Action]\label{ax:input}
    \begin{displaymath}
\{\length(ch)=1\}\res(a)\{\length(ch)=0\}
    \end{displaymath}
  \end{axiom}
where \(\length(ch)\) is the number of messages on a channel.

For any history $H$, \(\inv(a)\) is not contiguous to other output action \(\inv(a)\).
For example, if events \(\inv(a(v))\), \(\inv(a(v'))\), \(\res(a(v))\), \(\res(a(v'))\) lie within $H$ then 
\(\inv(a(v))\res(a(v))\inv(a(v'))\linebreak\res(a(v'))\), and \(\inv(a(v'))\res(a(v'))\inv(a(v))\res(a(v))\) are acceptable.
But, \(\inv(a(v))\inv(a(v'))\linebreak\res(a(v'))\res(a(v))\), and \(\inv(a(v'))\inv(a(v))\res(a(v))\res(a(v'))\) are not acceptable.
  \begin{lemma}\label{lm:seq}
An invocation \(\inv(a)\) for channel $a$ does not contiguous to \(\inv(a)\), and also a response \(\res(a)\) does not contiguous to \(\res(a)\).
  \end{lemma}
  \begin{proof}
Describe a sequential history $H$ for channel $a$.
\(\inv(a)\) is partial.
If \(\length(a)=1\) then the invocation is blocked.
From \axref{ax:output}, if \(\length(a)=0\) then \(\length(a)=1\) after \(\inv(a)\) occurs.
From \axref{ax:input}, \(\res(a)\) is invoked only if \(\length(a)=1\).
If \(\length(a)=0\) then an response of \(a\) is blocked.
Thereby, for any history $H$, $H$ is sequential.
Thus, \(\inv(a)\) (\(\res(a)\)) is not contiguous.
\QED
  \end{proof}
\lmref{lm:seq} stats that all history must be sequential.
The opposite of \lmref{lm:seq}, i.e. there are no contiguous invocations in a sequential history, is explicit by the definition of sequential history.
  \begin{theorem}\label{th:onetoone}
One output action corresponds with one input action, and one input action corresponds with one output action.
  \end{theorem}
  \begin{proof}
Pick a derivation \(\langle S,P\rangle\in Poss_m\) showing that $H$ is linearizable.
From \Lmref{lm:seq} \(\res(a)\mbox{ (is an input action)}\) is contiguous to \(\inv(a)\mbox{ (is an output action)}\), and \(\inv(a)\) is contiguous to \(\res(a)\) on $S$.
From \axref{ax:closure} Closure, if \(\inv(a)\in P\), then \(\langle S\inv(a)\res(a), P-\{\inv(a)\}\rangle\in Poss_m\).
Thus, all output action has a matching input action, and all input action has a matching output action.
\QED
  \end{proof}
\thref{th:onetoone} implies the following theorem.
  \begin{theorem}
No value is written twice, and no value is read twice.
  \end{theorem}
  \begin{proof}
From \lmref{lm:seq} all history is sequential.
From \thref{th:onetoone} subhistory \(\linebreak\inv(a(v))\inv(a(v))\) is not invoked.
A subhistory \(\res(a(v))\res(a(v))\) is also invoked.
Thus, same values are not written into a channel and read from a channel.
\QED
  \end{proof}
  \begin{theorem}\label{th:notvanish}
If an invocation \(\inv(a(v))\) precedes \(\inv(a(v'))\) and \(\res(a(v'))\) has occurred, then \(\res(a(v))\) must precede \(\inv(a(v'))\).
  \end{theorem}
  \begin{proof}
Pick a derivation \(\langle S,P\rangle\in Poss_m\) showing that $H$ is linearizable.
From \thref{lm:seq}, \(\res(a(v))\) must precedes \(\inv(a(v'))\), and must adapt \axref{ax:closure} for \(\inv(a(v))\) and \(\res(a(v))\) in $S$.
Thus, $v$ on channel $a$ by \(\res(a(v))\) does not vanish until \(\res(a(v))\) is invoked.
\QED
  \end{proof}
\Thref{th:notvanish} implies that messages do not spontaneously vanish form a channel.
  \begin{theorem}
If a response \(\res(a)\) is invoked then \(\inv(a)\) has been invoked before \(\res(a)\) and \(\res(a)\) does not precede \(\inv(a)\).
  \end{theorem}
  \begin{proof}
Pick a derivation \(\langle S,P\rangle\in Poss_m\) showing that $H$ is linearizable.
\(\res(a)\) occurs at $m$ in $H$.
From \axref{ax:response} Response, 
\(\{\langle S,P\rangle\in Poss\mbox{ and }\inv(op)\not\in P\mbox{ and }\res(op)=\last(S)\}\res(op)\{\langle S,P\rangle\in Poss'\}\).
$H$ is legal only if \(\inv(a)\) occur at \(i(<m)\).
\axref{ax:closure} application is included.
Then, for \(i\leq j\leq m\), \(\langle S',P'\rangle\in Poss_j\) and \(\inv(a)\in P'\).
Also, \(\langle S'\inv(a)\res(a),P'-\{\inv(a)\}\rangle\in Poss_j\).
Thus, \(\res(a)\) does not precede \(\inv(a)\).
\QED
  \end{proof}

Channels in \NHK are implemented by queue.
Each output action is implemented by \(\enq\) operation on queue, and each input action is implemented by \(\deq\) operation.
A history is an event sequence interleaved actions with operations of the implementation.

An implementation is correct if for every history $H$ \(H|a\) is linearizable.
Let $H$ be a interleaved history.
We focus on showing that for all \(H|m\)% \(0\leq\length(m)\leq 1\) and 
  \begin{displaymath}
\langle S_m,P_m\rangle\in Poss_{H|m}\Rightarrow\langle S_{a},P_{a}\rangle\in Poss_{H|a}.
  \end{displaymath}

We define an abstract function: \({\cal A}(m):M\rightarrow Ch\) so that it maps each state of the implementation to a state of an abstract data.
$M$ is a set of states of queue and $Ch$ is a set of states of channel.
  \begin{displaymath}
{\cal A}(m)=\{a|\,(m=a=[v])\vee(m=a=\emptyset)\},
  \end{displaymath}
The order of items in buffer does not need because the queue implementation must satisfy \thref{th:bound} \(0\leq\length(m)\leq 1\).

  \begin{theorem}
A transmission via action is atomic.
  \end{theorem}
  \begin{proof}
Assosiation between a message media $m$ and a channel $a$
    \begin{eqnarray*}
\inv(a(v))&\equiv&\inv(\enq(v))\res(\enq(v)),\\
\res(a(v))&\equiv&\inv(\deq(v))\res(\deq(v)).
    \end{eqnarray*}
Then, by \axref{ax:enque} and \axref{ax:deque}
  \begin{displaymath}
\{{\cal A}(m)=\emptyset\}[\inv(a(v) (=\inv(\enq(v))/\res(\enq(v)))]\{{\cal A}(m)=[v]\}
  \end{displaymath}
and
  \begin{displaymath}
\{{\cal A}(m)=[v]\}[\res(a(v) (=\inv(\deq(v))/\res(\deq(v)))]\{{\cal A}(m)=\emptyset\mbox{ and }v=\res(a(v))\}
  \end{displaymath}
These sequences satisfy \axref{ax:output} and \axref{ax:input}.

We need to show that if \(H|m\) is linearizable then \(H|a\) is also linearizable.
It suffices to show that \({\cal A}(m)\) is included in a set of results which \(S_a\) causes.
Pick \(\langle S_m,P_m\rangle\in Poss_{H|m}\).
If the last inference is \axref{ax:closure} for \(\enq(v)\), then the later events of \(S_m\) are \(\inv(\enq(v))\res(\enq(v))\), and the last event of \(H|a\) is \(\inv(a(v))\).
Also \(m=[v]\), so \({\cal A}(m)=[v]\).
At this moment \(\langle S_{a},P_{a}\rangle\in Poss_{H|a}\) and \(\inv(a(v))\in P_{a}\).
By \thref{th:bound} \(\inv(\deq(v))\res(\deq(v))\) is contiguous to \(\inv(\enq(v))\res(\enq(v))\).
Then, \(H|a\,\res(a(v))\) and \(S_a\,\inv(a(v))\res(a(v))\), thereby \(a=\emptyset\) or \([v]\).
Therefore \({\cal A}(m)\in\{\emptyset, [v]\}\).

Moreover, if the last inference is \axref{ax:closure} for \(\deq(v)\), then the later events of \(S_m\) are \(\inv(\deq(v))\res(\deq(v))\), and the last event of \(H|a\) is \(\res(a(v))\).
Also \(m=\emptyset\), so \({\cal A}(m)=\emptyset\).
At this moment \(\langle S_{a},P_{a}\rangle\in Poss_{H|a}\), thereby \(a=\emptyset\).
Therefore \({\cal A}(m)\in\{\emptyset\}\).

By \thref{th:bound} \(\inv(\enq(v'))\res(\enq(v'))\) is contiguous to \(\inv(\deq(v))\res(\deq(v))\).
Thus \({\cal A}(m)\) is included in a set of states which linearizations cause.
\QED
  \end{proof}
%
%%% SYNTAX
%
\section{Syntax of Model Description Language}
\subsection{Primitive Type}
RCCS has two types, integer and string.
Operator {\tt +,-,/,*} are defined over these types.
\subsection{Special Actions and Processes}
Action {\tt key} and {\tt display} are special actions. 
{\tt key} is used as an input action corresponding to the standard input, and {\tt display} is used as an output action corresponding to the standard output.
{\tt accept} is used to represents accept states of an automaton produced from a given LTL formula in verification mode.
Those special actions distinguish between upper letters and lower letters.

Process {\tt ZERO} and {\tt STOP} are a special process that means do nothing, not terminate the whole.
\NHK uses a special process {\tt INIT\_STATE} in verification mode.
The process means an initial state of an automaton for a LTL formula given by users.
{\tt ABORT} terminates the whole process for an automaton, but users cannot use in a model.
Those special processes do not distinguish between upper letters and lower letters.
\subsection{Scope}
In expression (define P (x) body), the scope of x becomes body.
In expression (\bijection{a}(x)\(\colon\) body), the scope of x becomes body.

Unfortunately, we use dynamic binding.
In future, we will fix it.
\subsection{Syntax of the Description Language}\label{sec:RCCSsyntax}
\input{ss02-grm}
\subsection{Sorts and Derivatives of Processes}
We make the notion of sort which is a little difference from syntactic sort in \cite{mil:book}.
If actions of a process \(P\) and all its derivatives
  \begin{displaymath}
    \begin{array}{rcl}
\sort{ZERO}&=&\emptyset\\
\sort{a\colon P}&=&\{a\}\cup\sort{P}\\
\sort{\sim a\colon P}&=&\{\sim a\}\cup\sort{P}\\
\sort{P\mbox{++}Q}&=&\sort{P}\cup\sort{Q}\\
\sort{P\|Q}&=&\sort{P}\cup\sort{Q}\\
\sort{\mbox{if}\ b\ P\ Q}&=&\sort{P}\cup\sort{Q}\\
\sort{A}&=&\sort{P} \mbox{  if $A\procdef P$}
    \end{array}
  \end{displaymath}
We distinguish names and co-names, and the observation of pairs of matching actions is possible because it is used to determine a next transition of the entire of processes.

We make the notion of syntactic derivative of sort \(\sort{P}\) which is used in the definition of operational semantics.
All derivatives lie in \(\sort{P}\) of \(P\) is syntactic immediate derivatives.
Describing an action sequence \(\alpha_1,\cdots,\alpha_n\) in which each element is an element of \(\sort{P}\) of \(P\), we call a process of the sequence
 and a set of them writes \(\derivative{P}\).
\(\derivative{ZERO}\) is \(\{ZERO\}\).
\subsection{RCCS Operational Semantics}\label{OPERATINAL_SEMANTICS}
\input{manual-sem}
\section{Coroutine-Like Sequencing}
An important application of coroutine is discrete event simulation, where coroutine may be used to simulate parallel processes within the framework of a sequential program.
\section{Syntax of Formulae}
We use LTL to describe goal properties of processes.
We first assume that a trace has initial states and is a finite sequence of states.
We write the length of trace \(\sigma=s_0\,s_1\,\cdots\,s_n\) to \(|\sigma|\) in which \(|\sigma|\) is \(n+1\).
We write the suffix of \(\sigma=s_0\,s_1\,\cdots\,s_i\,\cdots\,s_n\) starting at \(i\) as \(\suffix{\sigma}{i}=s_i\,\cdots\,s_n\), and the \(i^{\mbox{th}}\) state as \(\sigma^i\).

We assume a vocabulary \(x,y,z,\cdots\) of variables for data values.
For each state, variables are assigned to a single value.
A state formula is any well-formed first-order formula constructed over the given variables.
Such state formulas are evaluated on a single state to a boolean value.
If the evaluation of state formula \(p\) becomes true over \(s\), then we write \(s\lsquarebracket p\rsquarebracket=\true\) and say that \(s\) satisfies \(p\), where $\true$ and $\false$ are truth values, denoting \(true\) and \(false\) respectively.
Let $\varphi$ and $\psi$ be temporal formulas, a temporal formula is inductively constructed as follows:
  \begin{itemize}
\item a state formula is a temporal formula,
\item the negation of a temporal formula \(\neg\varphi\) is a temporal formula,
\item \(\varphi\vee\psi\) and \(\varphi\wedge\psi\) are temporal formulas, and
\item \(\ltlbox\,\varphi\), \(\ltldiammond\,\varphi\), \(\ltlnext\,\varphi\), and \(\varphi\ltluntil\psi\) are temporal formulas.
  \end{itemize}

We provide the formal syntax with BNF notation.
\input{manual-ltlgrm}
\section{Semantics of Property Description Language}
We next define two semantics of temporal formulas over a finite trace according to \cite{Eisner:2003}.
If trace \(\sigma\) satisfies property \(\varphi\), then we write \(\sigma\models\varphi\).
\subsection{Strong Semantics}
Furthermore,
  \begin{itemize}
\item if $p$ is a state formula, then \(\sigma\models p\) iff \(\sigma^0\lsquarebracket p\rsquarebracket=\true\) and \(|\sigma|\neq 0\),
\item \(\sigma\models\neg\varphi\) iff \(\sigma\not\models\varphi\),
\item \(\sigma\models\varphi\vee\psi\) iff \(\sigma\models\varphi\) or \(\sigma\models\psi\),
\item \(\sigma\models\varphi\wedge\psi\) iff \(\sigma\models\varphi\) and \(\sigma\models\psi\),
\item \(\sigma\models\ltlbox\varphi\) iff for all \(0\leq i<|\sigma|\), \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltldiammond\varphi\) iff there exists \(0\leq i<|\sigma|\) such that \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltlnext\varphi\) iff \(\sigma'\models\varphi\) where \(\sigma'=\sigma\) if \(|\sigma|=1\) and \(\sigma'=\suffix{\sigma}{1}\) if \(|\sigma|>1\),
\item \(\sigma\models\varphi\ltluntil\psi\) iff there exists \(0\leq k<|\sigma|\) s.t. \(\sigma\models\psi\) and for all \(j<k\), \(\sigma\models\varphi\).
  \end{itemize}

A formula \(\varphi\) is satisfiable if there exists a sequence \(\sigma\) such that \(\sigma\models \varphi\).
Given set of traces $T$ and formula \(\varphi\), \(\varphi\) is valid over $T$ if for all \(\sigma\in T\), \(\sigma\models\varphi\).
\subsection{Weak Semantics}
Furthermore,
  \begin{itemize}
\item if $p$ is a state formula, then \(\sigma\models p\) iff \(\sigma^0\lsquarebracket p\rsquarebracket=\true\) or \(|\sigma|=0\),
\item \(\sigma\models\neg\varphi\) iff \(\sigma\not\models\varphi\),
\item \(\sigma\models\varphi\vee\psi\) iff \(\sigma\models\varphi\) or \(\sigma\models\psi\),
\item \(\sigma\models\varphi\wedge\psi\) iff \(\sigma\models\varphi\) and \(\sigma\models\psi\),
\item \(\sigma\models\ltlbox\varphi\) iff for all \(0\leq i<|\sigma|\), \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltldiammond\varphi\) iff there exists \(0\leq i<|\sigma|\) such that \(\suffix{\sigma}{i}\models\varphi\),
\item \(\sigma\models\ltlnext\varphi\) iff \(\sigma'\models\varphi\) where \(\sigma'=\sigma\) if \(|\sigma|=1\) and \(\sigma'=\suffix{\sigma}{1}\) if \(|\sigma|>1\),
\item \(\sigma\models\varphi\ltluntil\psi\) iff there exists \(0\leq k<|\sigma|\) s.t. \(\sigma\models\psi\) and for all \(j<k\), \(\sigma\models\varphi\).
  \end{itemize}
%
%%% RELATIONSHIPS BETWEEN MODELS AND FORMULAE
%
\section{Relationships between Models and Formulae}
In this subsection, we describe the relationship between algebraic models and LTL formulas.
The modeling language enables us to pass values via input prefix \(\alpha(e)\) and output prefix \(\bijection{\alpha}(x)\) with the same name.
Execution of \(\alpha(e)\) produces  value \(v\) of \(e\).
Execution of \(\bijection{\alpha}(x)\) causes a single assignment to \(x\).
Furthermore, the execution of two actions causes atomic assignment \(x \colon = v\), that is, communication between two agents produces a new state by changing the values of the variables.
This is similar to the first paragraph in Section~3.3 of \cite[page 290]{lamport84hoare}.

This atomic assignment changes states, and  we represent the change as \(s[v/x]\), which denotes a change in the values of \(x\) in \(s\) to \(v\).
A state is a mapping from variables to values.
Assuming that \(\tt Var_E\) is a set of variables that appears in prefixes in agent \(E\) with range \(\tt V\), \(s\colon Var_E\rightarrow {\tt V}\).
For example, the evaluation \(s\lsquarebracket x=y\rsquarebracket\) of \(x=y\) at \(s\) becomes \(s\lsquarebracket x\rsquarebracket=s\lsquarebracket y\rsquarebracket\), and at \(s[v/x]\), \(s[v/x]\lsquarebracket x\rsquarebracket=s[v/x]\lsquarebracket y\rsquarebracket\), i.e., \(v=s[y]\).

Therefore, communication between agents produces a sequence of assignments, which then produces a sequence of state changes called a trace.
Let a set of traces produced by agent \(E\) be \(T\).
If for all traces \(\sigma\in T\), \(\sigma\models\varphi\), then we state that \(\varphi\) is valid over \(E\) and write \(E\models\varphi\).
%
%%% TRANSITION OF AUTOMATA
%
\subsection{Transition of Automata}
A \buchi automaton $m$ contains of five components:
  \begin{itemize}
\item A finite set of states, denoted $Q$.
\item A finite set of input symbols, denoted $\Sigma$.
\item A transition function $\delta$ that takes a state and an input symbol, and returns a next state.
If $q$ is a state, and $s$ is an input symbol, then \(\delta(q,a)\) returns state $p$.
\item A start state $q_0$ is a state in $Q$.
\item A set of accepting states $Q_{\infty}$ is a subset of $Q$.
  \end{itemize}
In this paper, an input symbol becomes a state of a model.
We talk about an automaton $m$ in \emph{five-tuple} notation: \((Q,\Sigma,\delta,q_0,Q_{\infty})\).

Now, we need to make the notion of the language that an automaton accepts.
To do this, we define an extended transition function.
The extended transition function constructed from $\delta$ is called \(\hat{\delta}\).
We define \(\hat{\delta}\) by induction on the length of an input string $\sigma$, as follows:
  \begin{displaymath}
\hat{\delta}(q,\sigma)=\left\{
      \begin{array}{ll}
q & \mbox{if \(|\sigma |=0\)}\\
\delta(\hat{\delta}(q,\sigma^{..n-1}),\sigma^{n}) & \mbox{if \(0<|\sigma |<\omega\)}.
      \end{array}
\right.
  \end{displaymath}
We define the language \({\cal L} (m)\) of automaton $m$.
Let \(INF(\rho)\) be a set of automaton states that appear infinitely often in while reading $\sigma$,
then $\sigma$ is accepted by $m$ if and only if \(INF(\rho)\cap Q_{\infty}\neq\emptyset\).
Thus,
  \begin{displaymath}
{\cal L}(m)=\{\sigma\mid \rho^0=q^0, \forall i\colon\rho^i=\hat{\delta}(q_0,\sigma^{..i})\mbox{, and }INF(\rho)\cap Q_{\infty}\neq\emptyset\}.
  \end{displaymath}

\(\eta\) depends on weak or strong semantics.
In weak semantics, \(\eta\) is \(q\) that is regarded as an element of \(Q_{\infty}\).
In strong semantics, \(\eta\) is \(\Lambda\), where \(\Lambda\) is inconsistency.
%
%%% CORRESPONDENCE
%
\subsection{Correspondence between Models and Formulae}
We describe a correspondence between a model and a \buchi automaton of a formulae of a property which the model are required.
The correspondence is expressed with Hoare triple: \{P\}$\alpha$\{P'\},
where $P$ and $P'$ are boolean predicates, and $\alpha$ is an action which a model performs.

An automaton $m$ enters an automaton state \(q_j\) if there exists a history containing program state $s$ and $m$ is transformed from \(q_i\) into \(q_j\) by reading $s$.
We define \emph{correspondence invariant} by induction \cite{alpern:1987}.
\begin{definition}[Correspondece Basis]
  \begin{displaymath}
\forall i\colon q_j\in Q\mbox{ and }(Init_{\pi}\wedge T_{0j})\Rightarrow C_j,
  \end{displaymath}
where \(Init_{\pi}\) is the initial states of model \(\pi\).
\end{definition}
\begin{definition}[Correspondece Induction]
  \begin{displaymath}
\forall \alpha\colon\forall i\colon\alpha\in A\cup\bijection{A}\mbox{ and }q_i\in Q\mbox{ and }
\{C_i\}\alpha\{\wedge_{q_j\in Q}(T_{ij}\Rightarrow C_j)\}.
  \end{displaymath}
\end{definition}

%
%%% Proving Safety Properties
%
\subsection{Proving Safety Properties}
A model \(\pi\) written by our model language has the form: \(\pi=\pi_1\|\cdots\|\pi_n\).
Processes synchronize and communicate using input actions and output actions.
For a channel \(a\), a value of \(exp\) and a variable \(var\), execution of an output action
  \begin{displaymath}
\bijection{a}(exp)
  \end{displaymath}
causes the transfer of the value of \(exp\), and execution of a matching input action 
  \begin{displaymath}
a(var)
  \end{displaymath}
,which some other process performs, causes receive from channel \(a\).
an input action is delayed until some matching output action.

Two matching actions are executed as an atomic action which causes an assignment to \(var\):
  \begin{displaymath}
var\,=\,exp.
  \end{displaymath}
The atomic assignment which consists of two actions \(\bijection{a}\) and \(a\) occurs as a free-standing statement.
We regard the atomic assignment above as a fragment of models.

The set of atomic actions which make up program \(\pi\) is denoted \(\alpha[\pi]\).
If \(\pi\) is composed of fragments \(\pi_1,\cdots,\pi_n\) then:
  \begin{displaymath}
\alpha[\pi]=\alpha[\pi_1]\cup\cdots\cup\alpha[\pi_n]\cup\alpha[a_1]\cup\cdots\cup\alpha[a_n].
  \end{displaymath}

The tool guarantee matching semantics between input and output actions.
For example, \(P_1\|P_2\) in which each process is defined as follows does not produce input-output pairs \((\bijection{a}(1),a(x))\) and \((\bijection{a}(2),a(y))\):
  \begin{displaymath}
    \begin{array}{lcr}
P_1&=&a(x)\colon ZERO\mbox{++}\bijection{a}(0)\colon a(y)\colon ZERO,\\
P_2&=&\bijection{a}(2)\colon ZERO\mbox{++}a(z)\colon\bijection{a}(1)\colon ZERO.\\
    \end{array}
  \end{displaymath}

We present the following proof rules for all possible constructs of processes, according to \cite{Apt:1980}.
  \begin{displaymath}
\infer[\mbox{Input}]{\{p\}a(x)\{q\}}
                    {}
  \end{displaymath}
This axiom corresponds to A.1 in \cite{Apt:1980}.
The post assertion in this axiom will be checked against a corresponding output action with which some process cooperates.
  \begin{displaymath}
\infer[\mbox{Output}]{\{p\}\bijection{a}(y)\{q\}}
                    {}
  \end{displaymath}
This axiom may look strange since it has no side-effect.
We introduce this axiom corresponding to A.2' in \cite{Apt:1980} because the modelling language allows output actions without matching inputs.
Communication \(\{p\}\alpha(x)\colon P\|\bijection{\alpha}(y)\colon Q\{q\}\) does not derives an arbitrary predicate.
The form of $q$ restricts to the formula of \(\{p\}\alpha(x)\colon P\|\bijection{\alpha}(y)\colon Q\{x=y\wedge p\}\) where $x$ is not free in $p$.

Action prefixes mean sequential execution of actions.
This syntactical structure provides the following rule.
  \begin{displaymath}
\infer[\mbox{Sequence}]
      {\{p\}[\alpha\colon P]\{q\}}
      {\{p\}\alpha\{p'\}\ \{'p\}P\{q\}}
  \end{displaymath}

The meaning of the following rule is that the post condition of summation must be established along each possible path.
  \begin{displaymath}
\infer[\mbox{Summation}]{\{p\}P\mbox{++}Q\{q\}}
                        {\{p\}P\{q\}\ \{p\}Q\{q\}}
  \end{displaymath}
Using these axioms and rules, we can establish the proof for a formula for each process.

We now present a proof rule and an axiom for communication among processes.
The rule to used to deduce a property of \(P\|Q\) has the following form:
  \begin{displaymath}
\infer[\mbox{Composition}]{\{p_1\wedge p_2\}P\|Q\{q_1\wedge q_2\}}
                        {\{p_1\}P\{q_1\}\ \{p_2\}Q\{q_2\}}
  \end{displaymath}
The meaning of this rule is that proofs cooperate to help each other proof to validate the post conditions of input/output actions.
We shall need the following axiom to establish cooperation:
  \begin{displaymath}
\infer[\mbox{Communication}]
      {\{True\}[a(x)\colon P\|\bijection{a}(y)\colon Q]\{x=y\}}
      {}
  \end{displaymath}
%
%%% BIBLIOGRAPHY
%
\bibliographystyle{alpha}
\bibliography{reference}

\end{document}

